/*
* jQuery easyShare plugin
* Update on 28 december 2011
* Version 1.0
*
* Licensed under GPL <http://en.wikipedia.org/wiki/GNU_General_Public_License>
* Copyright (c) 2008, St√©phane Litou <contact@mushtitude.com>
* All rights reserved.
*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

(function($){
$.fn.easyPaginate = function (options) {
    var defaults = {
        paginateElement: 'li',
        hashPage: 'page',
        elementsPerPage: 10,
        effect: 'default',
        slideOffset: 200,
        firstButton: true,
        firstButtonText: '<<',
        lastButton: true,
        lastButtonText: '>>',        
        prevButton: true,
        prevButtonText: '<',        
        nextButton: true,
        nextButtonText: '>'
    }
        
    return this.each (function (instance) {        
        
        var plugin = {};
        plugin.el = $(this);
        plugin.el.addClass('easyPaginateList');

        plugin.settings = {
            pages: 0,
            objElements: Object,
            currentPage: 1
        }
        
        var getNbOfPages = function() {
            return Math.ceil(plugin.settings.objElements.length / plugin.settings.elementsPerPage);         
        };
        
        var displayNav = function() {
            htmlNav = '<div class="easyPaginateNav">';
            
            if(plugin.settings.firstButton) {
                htmlNav += '<a href="#'+plugin.settings.hashPage+':1" title="First page" rel="1" class="first">'+plugin.settings.firstButtonText+'</a>';
            }
            
            if(plugin.settings.prevButton) {
                htmlNav += '<a href="" title="Previous" rel="" class="prev">'+plugin.settings.prevButtonText+'</a>';
            }
            
            for(i = 1;i <= plugin.settings.pages;i++) {
                htmlNav += '<a href="#'+plugin.settings.hashPage+':'+i+'" title="Page '+i+'" rel="'+i+'" class="page">'+i+'</a>';
            };
            
            if(plugin.settings.nextButton) {
                htmlNav += '<a href="" title="Next" rel="" class="next">'+plugin.settings.nextButtonText+'</a>';
            }
            
            if(plugin.settings.lastButton) {
                htmlNav += '<a href="#'+plugin.settings.hashPage+':'+plugin.settings.pages+'" title="Last page" rel="'+plugin.settings.pages+'" class="last">'+plugin.settings.lastButtonText+'</a>';
            }
            
            htmlNav += '</div>';
            plugin.nav = $(htmlNav);
            plugin.nav.css({
                'width': plugin.el.width()
            });
            plugin.el.after(plugin.nav);

            var elSelector = '#' + plugin.el.get(0).id + ' + ';
            $(elSelector + ' .easyPaginateNav a.page,'
                + elSelector + ' .easyPaginateNav a.first,'
                + elSelector + ' .easyPaginateNav a.last').on('click', function(e) {
                e.preventDefault();
                displayPage($(this).attr('rel'));                
            });

            $(elSelector + ' .easyPaginateNav a.prev', plugin).on('click', function(e) {
                e.preventDefault();
                page = plugin.settings.currentPage > 1?parseInt(plugin.settings.currentPage) - 1:1;
                displayPage(page);
            });

            $(elSelector + ' .easyPaginateNav a.next', plugin).on('click', function(e) {
                e.preventDefault();
                page = plugin.settings.currentPage < plugin.settings.pages?parseInt(plugin.settings.currentPage) + 1:plugin.settings.pages;
                displayPage(page);
            });
        };
        
        var displayPage = function(page, forceEffect) {
            if(plugin.settings.currentPage != page) {
                plugin.settings.currentPage = parseInt(page);
                offsetStart = (page - 1) * plugin.settings.elementsPerPage;
                offsetEnd = page * plugin.settings.elementsPerPage;
                if(typeof(forceEffect) != 'undefined') {
                    eval("transition_"+forceEffect+"("+offsetStart+", "+offsetEnd+")");
                }else {
                    eval("transition_"+plugin.settings.effect+"("+offsetStart+", "+offsetEnd+")");
                }
                
                plugin.nav.find('.current').removeClass('current');
                plugin.nav.find('a.page:eq('+(page - 1)+')').addClass('current');
                
                switch(plugin.settings.currentPage) {
                    case 1:
                        $('.easyPaginateNav a', plugin).removeClass('disabled');
                        $('.easyPaginateNav a.first, .easyPaginateNav a.prev', plugin).addClass('disabled');
                        break;
                    case plugin.settings.pages:
                        $('.easyPaginateNav a', plugin).removeClass('disabled');
                        $('.easyPaginateNav a.last, .easyPaginateNav a.next', plugin).addClass('disabled');
                        break;
                    default:
                        $('.easyPaginateNav a', plugin).removeClass('disabled');
                        break;
                }
            }
        };
        
        var transition_default = function(offsetStart, offsetEnd) {
            plugin.currentElements.hide();
            plugin.currentElements = plugin.settings.objElements.slice(offsetStart, offsetEnd).clone();
            plugin.el.html(plugin.currentElements);
            plugin.currentElements.show();
        };
        
        var transition_fade = function(offsetStart, offsetEnd) {
            plugin.currentElements.fadeOut();
            plugin.currentElements = plugin.settings.objElements.slice(offsetStart, offsetEnd).clone();
            plugin.el.html(plugin.currentElements);
            plugin.currentElements.fadeIn();
        };
        
        var transition_slide = function(offsetStart, offsetEnd) {
            plugin.currentElements.animate({
                'margin-left': plugin.settings.slideOffset * -1,
                'opacity': 0
            }, function() {
                $(this).remove();
            });
            
            plugin.currentElements = plugin.settings.objElements.slice(offsetStart, offsetEnd).clone();
            plugin.currentElements.css({
                'margin-left': plugin.settings.slideOffset,
                'display': 'block',
                'opacity': 0,
                'min-width': plugin.el.width() / 2
            });
            plugin.el.html(plugin.currentElements);
            plugin.currentElements.animate({
                'margin-left': 0,
                'opacity': 1
            });
        };
                
        var transition_climb = function(offsetStart, offsetEnd) {            
            plugin.currentElements.each(function(i) {
                var $objThis = $(this);
                setTimeout(function() {
                    $objThis.animate({
                        'margin-left': plugin.settings.slideOffset * -1,
                        'opacity': 0
                    }, function() {
                        $(this).remove();
                    });
                }, i * 200);
            });
            
            plugin.currentElements = plugin.settings.objElements.slice(offsetStart, offsetEnd).clone();
            plugin.currentElements.css({
                'margin-left': plugin.settings.slideOffset,
                'display': 'block',
                'opacity': 0,
                'min-width': plugin.el.width() / 2
            });
            plugin.el.html(plugin.currentElements);
            plugin.currentElements.each(function(i) {
                var $objThis = $(this);
                setTimeout(function() {
                    $objThis.animate({
                        'margin-left': 0,
                        'opacity': 1
                    });
                }, i * 200);
            });
        };
                
        plugin.settings = $.extend({}, defaults, options);
        
        plugin.currentElements = $([]);
        plugin.settings.objElements = plugin.el.find(plugin.settings.paginateElement);
        plugin.settings.pages = getNbOfPages();
        if(plugin.settings.pages > 1) {
            plugin.el.html();
    
            // Here we go
            displayNav();
            
            page = 1;
            if(document.location.hash.indexOf('#'+plugin.settings.hashPage+':') != -1) {
                page = parseInt(document.location.hash.replace('#'+plugin.settings.hashPage+':', ''));
                if(page.length <= 0 || page < 1 || page > plugin.settings.pages) {
                    page = 1;
                }
            }
            
            displayPage(page, 'default');
        }
    });
};
})(jQuery);
/*! Nestoria Slider - v1.0.13 - 2015-07-16
* http://lokku.github.io/jquery-nstslider/
* Copyright (c) 2015 Lokku Ltd.; Licensed MIT */
(function($) {
    /* 
     * These are used for user interaction. This plugin assumes the user can
     * interact with one control at a time. For this reason it's safe to keep
     * these global.
     */
    var _$current_slider;
    var _is_mousedown;
    var _original_mousex;

    // both for keyboard and mouse interaction
    var _is_left_grip;

    // for keyboard interaction only
    var _before_keydown_value;
    var _before_keydown_pixel;
    var _before_keyup_value;
    var _before_keyup_pixel;

    // a fixed configuration for the single bar slider, used to decide where to
    // place the naked bar.
    var _naked_bar_deltas; // see populateNakedBarDeltas

    var _methods = {
         /*
          * This method must be called once during initialization.
          * It sets the behaviour of the naked bar in case of one handle.
          */
         'setNakedBarDelta': function (position, handleWidth) {
             if (position === "stickToSides") {
                _naked_bar_deltas = {
                    toEndWidth: handleWidth,
                    toBeginLeft: 0,
                    toBeginWidth: handleWidth
                };
             }
             else if (position === "middle") {
                // Position naked end of the bar at the middle value.
                _naked_bar_deltas = {
                    toEndWidth: handleWidth/2,
                    toBeginLeft: handleWidth/2,
                    toBeginWidth: handleWidth/2
                };
             }
             else {
                throw new Error('unknown position of setNakedBarDelta: ' + position);
             }
         },
         'getSliderValuesAtPositionPx' : function (leftPx, rightPx) {
              var $this = this,
                  leftPxInValue, rightPxInValue,
                  pixel_to_value_mapping_func = $this.data('pixel_to_value_mapping');

              if (typeof pixel_to_value_mapping_func !== 'undefined') {
                  leftPxInValue = pixel_to_value_mapping_func(leftPx);
                  rightPxInValue = pixel_to_value_mapping_func(rightPx);
              }
              else {
                  var w = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width');
                  leftPxInValue = _methods.inverse_rangemap_0_to_n.call($this, leftPx, w);
                  rightPxInValue = _methods.inverse_rangemap_0_to_n.call($this, rightPx, w);
              }

              return [leftPxInValue, rightPxInValue];
         },
         /*
          *  Move slider grips to the specified position. This method is
          *  designed to run within the user interaction lifecycle. Only call
          *  this method if the user has interacted with the sliders
          *  actually...
          *
          *  First the desired positions are validated. If values are ok, the
          *  move is performed, otherwise it's just ignored because weird
          *  values have been passed.
          */
         'validateAndMoveGripsToPx' : function (nextLeftGripPositionPx, nextRightGripPositionPx) {
             var $this = this;

             var draggableAreaLengthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width');

             //
             // Validate & Move
             //
             if (nextRightGripPositionPx <= draggableAreaLengthPx && 
                 nextLeftGripPositionPx >= 0 &&
                 nextLeftGripPositionPx <= draggableAreaLengthPx && 
                 (!$this.data('has_right_grip') || nextLeftGripPositionPx <= nextRightGripPositionPx) ) {

                 var prevMin = $this.data('cur_min'),                        
                     prevMax = $this.data('cur_max');       

                 // note: also stores new cur_min, cur_max
                 _methods.set_position_from_px.call($this, nextLeftGripPositionPx, nextRightGripPositionPx);

                 // set the style of the grips according to the highlighted range
                 _methods.refresh_grips_style.call($this);

                 _methods.notify_changed_implicit.call($this, 'drag_move', prevMin, prevMax);
             }

             return $this;
         },
         /*
          * Update aria attributes of the slider based on the current
          * configuration of the slider.
          */
         'updateAriaAttributes' : function () {
            var $this = this,
                settings = $this.data('settings'),
                $leftGrip = $this.find(settings.left_grip_selector);

            //
            // double grips sliders is probably the most common case...
            // ... also, the values to be set in the two cases are quite
            // different.
            //
            if ($this.data('has_right_grip')) {

                var $rightGrip = $this.find(settings.right_grip_selector);

                //
                // grips are mutually binding their max/min values when 2 grips
                // are present. For example, we should imagine the left grip as
                // being constrained between [ rangeMin, valueMax ]
                //
                $leftGrip
                    .attr('aria-valuemin', $this.data('range_min'))
                    .attr('aria-valuenow', methods.get_current_min_value.call($this))
                    .attr('aria-valuemax', methods.get_current_max_value.call($this));

                $rightGrip
                    .attr('aria-valuemin', methods.get_current_min_value.call($this))
                    .attr('aria-valuenow', methods.get_current_max_value.call($this))
                    .attr('aria-valuemax', $this.data('range_max'));
            }
            else {
                $leftGrip
                    .attr('aria-valuemin', $this.data('range_min'))
                    .attr('aria-valuenow', methods.get_current_min_value.call($this))
                    .attr('aria-valuemax', $this.data('range_max'));
            }

            return $this;
         },
         /*
          * Return the width in pixels of the slider bar, i.e., the maximum
          * number of pixels the user can slide the slider over. This function
          * should always be used internally to obtain the width of the
          * slider in pixels!
          */
         'getSliderWidthPx' : function () {
            var $this = this;

            //
            // .width() can actually return a floating point number! see
            // jquery docs!
            //
            return Math.round($this.width());
         },
         /*
          * Return the position of a given grip in pixel in integer format.
          * Use this method internally if you are literally going to get the
          * left CSS property from the provided grip.
          *
          * This method assumes a certain grip exists and will have the left
          * property.
          *
          * This is generally safe for the left grip, because it is basically
          * guaranteed to exist. But for the right grip you should be really
          * using getRightGripPositionPx instead.
          *
          */
         'getGripPositionPx' : function ($grip) {
            return parseInt($grip.css('left').replace('px',''), 10);
         },
         /*
          * Just the same as getGripPositionPx, but there is no need to provide
          * the $slider.
          */
         'getLeftGripPositionPx' : function () {
            var $this = this,
                settings = $this.data('settings'),
                $leftGrip = $this.find(settings.left_grip_selector);

            return _methods.getGripPositionPx.call($this, $leftGrip);
         },
         /*
          * Return the position of the right Grip if it exists or return the
          * current position if not. Even if the right grip doesn't exist, its
          * position should be defined, as it determines the position of the 
          * bar.
          */
         'getRightGripPositionPx' : function () {
            var $this = this,
                settings = $this.data('settings');

                if ($this.data('has_right_grip')) {
                    return _methods.getGripPositionPx.call($this,
                        $this.find(settings.right_grip_selector)
                    );
                }

                // default
                var sliderWidthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width');
                return _methods.rangemap_0_to_n.call($this, $this.data('cur_max'), sliderWidthPx);
         },
         /*
          * Return the width of the left grip.  Like getSliderWidthPx, this
          * method deals with .width() returning a floating point number. All
          * the code in this plugin assumes an integer here!
          */
         'getLeftGripWidth' : function () {
            var $this = this,
                settings = $this.data('settings'),
                $leftGrip = $this.find(settings.left_grip_selector);

            return Math.round($leftGrip.outerWidth());
         },
         /*
          * Return the width of the right grip. The calling method should
          * check that the right grip actually exists. This method assumes it
          * does.
          */
         'getRightGripWidth' : function () {
            var $this = this,
                settings = $this.data('settings'),
                $rightGrip = $this.find(settings.right_grip_selector);

            return Math.round($rightGrip.outerWidth());
         },
         'binarySearchValueToPxCompareFunc' : function (s, a, i) {
            // Must return:
            //
            // s: element to search for
            // a: array we are looking in 
            // i: position of the element we are looking for
            //
            // -1 (s < a[i])
            // 0  found (= a[i])
            // 1  (s > a[i])
            if (s === a[i])          { return 0; }  // element found exactly
            if (s < a[i] && i === 0) { return 0; }  // left extreme case e.g., a = [ 3, ... ], s = 1
            if (a[i-1] <= s && s < a[i]) { return 0; } // s is between two elements, always return the rightmost
            if (s > a[i])           { return 1;  }
            if (s <= a[i-1])        { return -1; }
            $.error('cannot compare s: ' + s + ' with a[' + i + ']. a is: ' + a.join(','));
         },
         /*
          * Perform binary search to find searchElement into a generic array.
          * It uses a customized compareFunc to perform the comparison between
          * two elements of the array and a getElement function to pick the
          * element from the array (e.g., in case we want to pick a field of an
          * array of objects)
          */
         'binarySearch' : function(array, searchElement, getElementFunc, compareFunc) {
              var minIndex = 0;
              var maxIndex = array.length - 1;
              var currentIndex;
              var currentElement;

              while (minIndex <= maxIndex) {
                  currentIndex = (minIndex + maxIndex) / 2 | 0;
                  currentElement = getElementFunc(array, currentIndex);

                  // lt = -1 (searchElement < currentElement)
                  // eq = 0 
                  // gt = 1  (searchElement > currentElement)
                  var lt_eq_gt = compareFunc(searchElement, array, currentIndex);

                  if (lt_eq_gt > 0) {
                      minIndex = currentIndex + 1;
                  }
                  else if (lt_eq_gt < 0) {
                      maxIndex = currentIndex - 1;
                  }
                  else {
                      return currentIndex;
                  }
              }

              return -1;
        },
        /*
         * Returns true if this slider has limit, false otherwise. There can be
         * an upper limit and a lower limit for the sliders.
         * The lower/upper limits are values that are out of the slider range,
         * but that can be selected by the user when he moves a slider all the
         * way down the minimum and up to the maximum value.
         */
        'haveLimits' : function () {
            var $this = this,
                lowerLimit = $this.data('lower-limit'),
                upperLimit = $this.data('upper-limit'),
                haveLimits = false;

            if (typeof lowerLimit !== 'undefined' && 
                typeof upperLimit !== 'undefined') {
                
                haveLimits = true;
            }

            return haveLimits;
        },
        /*
         * This method is called whenever the style of the grips needs to get
         * updated.
         */
        'refresh_grips_style' : function () {
            var $this = this,
            settings = $this.data('settings');

            // Skip refreshing grips style if no hihglight is specified in
            // construction
            if (typeof settings.highlight === 'undefined') {
                return;
            }

            var highlightedRangeMin = $this.data('highlightedRangeMin');

            if (typeof highlightedRangeMin === 'undefined') {
                return;
            }

            var $leftGrip = $this.find(settings.left_grip_selector),
                $rightGrip = $this.find(settings.right_grip_selector),
                highlightedRangeMax = $this.data('highlightedRangeMax'),
                curMin = $this.data('cur_min'),
                curMax = $this.data('cur_max'),
                highlightGripClass = settings.highlight.grip_class;

            // curmin is within the highlighted range
            if (curMin < highlightedRangeMin || curMin > highlightedRangeMax) {
                // de-highlight grip
                $leftGrip.removeClass(highlightGripClass);
            }
            else {
                // highlight grip
                $leftGrip.addClass(highlightGripClass);
            }

            // time to highlight right grip
            if (curMax < highlightedRangeMin || curMax > highlightedRangeMax) {
                // de-highlight grip
                $rightGrip.removeClass(highlightGripClass);
            }
            else {
                // highlight grip
                $rightGrip.addClass(highlightGripClass);
            }
        },
        /* 
         *  Set left and right handle at the right position on the screen (pixels) 
         *  given the desired position in currency.
         * 
         *  e.g., _methods.set_position_from_val.call($this, 10000, 100000);
         *        
         *        may set the left handle at 100px and the right handle at
         *        200px;
         *   
         */
        'set_position_from_val' : function (cur_min, cur_max) {
            var $this = this;
            // 
            // We need to understand how much pixels cur_min and cur_max
            // correspond.
            //
            var range_min = $this.data('range_min'),
                range_max = $this.data('range_max');

            //
            // (safety) constrain the cur_min or the cur_max value between the
            // max/min ranges allowed for this slider.
            //
            if (cur_min < range_min) { cur_min = range_min; }
            if (cur_min > range_max) { cur_min = range_max; }

            if ($this.data('has_right_grip')) {
                if (cur_max > range_max) { cur_max = range_max; }
                if (cur_max < range_min) { cur_max = range_min; }
            }
            else {
                cur_max = $this.data('cur_max');
            }

            var leftPx = methods.value_to_px.call($this, cur_min),
                rightPx = methods.value_to_px.call($this, cur_max);

            _methods.set_handles_at_px.call($this, leftPx, rightPx);

            // save this position
            $this.data('cur_min', cur_min);

            if ($this.data('has_right_grip')) {
                $this.data('cur_max', cur_max);
            }

            return $this;
        },
        /*
         * Set the position of the handles at the specified pixel points (taking
         * the whole slider width as a maximum point).
         */
        'set_position_from_px' : function (leftPx, rightPx) {
            var $this = this;

            //
            // we need to find a value from the given value in pixels
            //

            // now set the position as requested...
            _methods.set_handles_at_px.call($this, leftPx, rightPx);

            var valueLeftRight = _methods.getSliderValuesAtPositionPx.call($this, leftPx, rightPx),
                leftPxInValue = valueLeftRight[0],
                rightPxInValue = valueLeftRight[1];

            // ... and save the one we've found.
            $this.data('cur_min', leftPxInValue);

            if ($this.data('has_right_grip')) {
                $this.data('cur_max', rightPxInValue);
            }

            return $this;
        },
        /*
         * Updates the CSS of grips and bar so that the left grip appears at
         * leftPx and the right grip appears at rightPx. Note: leftPx can be >
         * rightPx.
         */
        'set_handles_at_px' : function (leftPx, rightPx) {
            var $this = this;
            var settings = $this.data('settings');

            var left_grip_selector = settings.left_grip_selector,
                right_grip_selector = settings.right_grip_selector,
                value_bar_selector = settings.value_bar_selector;

            var handleWidth = $this.data('left_grip_width');

            // The left grip
            $this.find(left_grip_selector).css('left', leftPx + 'px');

            // The right grip
            $this.find(right_grip_selector).css('left', rightPx + 'px');

            // The value bar
            if ($this.data('has_right_grip')) {
                // If both the grips are there, the value bar must stick to
                // beginning and the end of the grips. 
                $this.find(value_bar_selector)
                    .css('left', leftPx + 'px')
                    .css('width', (rightPx - leftPx + handleWidth) + 'px');
            }
            else {
                if (!_naked_bar_deltas) {
                    _methods.populateNakedBarDeltas.call($this, leftPx, rightPx, handleWidth);
                }

                if (rightPx > leftPx) {
                    // The naked end of the bar is on the right of the grip
                    $this.find(value_bar_selector)
                        .css('left', leftPx + 'px')
                        .css('width', rightPx - leftPx + _naked_bar_deltas.toEndWidth + 'px');
                }
                else {
                    // The naked end of the bar is on the left of the grip
                    // NOTE: leftPx and rightPx are to be read swapped here.
                    $this.find(value_bar_selector)
                        .css('left', rightPx + _naked_bar_deltas.toBeginLeft + 'px')
                        .css('width', (leftPx - rightPx + _naked_bar_deltas.toBeginWidth) + 'px');
                }
            }

            return $this;
            
        },
        'drag_start_func_touch' : function (e, settings, $left_grip, $right_grip, is_touch) {
            var $this = this,
                original_event = e.originalEvent,
                touch = original_event.touches[0];

            // for touch devices we need to make sure we allow the user to scroll
            // if the click was too far from the slider.
            var curY = touch.pageY,
                curX = touch.pageX;

            // is the user allowed to grab if he/she tapped too far from the
            // slider?
            var ydelta = Math.abs($this.offset().top - curY),
                slider_left = $this.offset().left,
                xldelta = slider_left - curX,
                xrdelta = curX - (slider_left + $this.width());

            if (ydelta > settings.touch_tolerance_value_bar_y  ||
                xldelta > settings.touch_tolerance_value_bar_x ||
                xrdelta > settings.touch_tolerance_value_bar_x ) {

                return;
            }

            original_event.preventDefault();
            _original_mousex = touch.pageX;

            // true : is touch event
            _methods.drag_start_func.call($this, touch, settings, $left_grip, 
                $right_grip, is_touch);
        },
        'drag_start_func' : function (e, settings, $leftGrip, $rightGrip, 
                is_touch) {

            var $this = this;

            $this.find(settings.left_grip_selector + 
                ',' + settings.value_bar_selector + 
                ',' + settings.right_grip_selector).removeClass(

                settings.animating_css_class
            );
            
            if (!methods.is_enabled.call($this)) { return; }
        
            //
            // if the user used the finger, he/she is allowed to touch anywhere.
            // but if the mouse is used, we want to enable the logic only for
            // left grip, right grip, bar/panel elements.
            //
            var $target = $(e.target);

            // ... if the highlight range was enabled we should check wether
            // the user has tapped or clicked the highlight panel...
            var targetIsPanelSelector = false;
            if (typeof settings.highlight === 'object') {
                targetIsPanelSelector = $target.is(settings.highlight.panel_selector);
            }

            if (is_touch === false && 
                !$target.is(settings.left_grip_selector) &&
                !$target.is(settings.right_grip_selector) && 
                !$target.is(settings.value_bar_selector) &&
                !targetIsPanelSelector &&
                !$target.is($this) ) {

                return;
            }

            // - - - -
            // the following logic finds the nearest slider grip and starts
            // dragging it.
            // - - - -
            
            _$current_slider = $this;

            var leftGripPositionPx = _methods.getGripPositionPx.call($this, $leftGrip),
                sliderWidthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width'),
                lleft = $leftGrip.offset().left,
                rleft, // don't compute this yet (maybe not needed if 1 grip)
                curX,
                ldist,
                rdist,
                ldelta,
                rdelta;

            var rightGripPositionPx = _methods.getRightGripPositionPx.call($this);

            //
            // We need to do as if the click happened a bit more on the left.
            // That's because we will be setting the left CSS property at the
            // point where the click happened, meaning the slider grip will be
            // spanning to the right.
            //
            curX = Math.round(e.pageX) - ($this.data('left_grip_width') / 2);

            // calculate deltas from left and right grip
            ldist = Math.abs(lleft - curX);
            ldelta = curX - lleft;

            if ($this.data('has_right_grip')) {
                rleft = $rightGrip.offset().left;
                rdist = Math.abs(rleft - curX);
                rdelta = curX - rleft;
            }
            else {
                // no right grip... we make the right slider
                // unreachable!
                rdist = ldist * 2;
                rdelta = ldelta * 2;
            }
            
            // notify the beginning of a dragging...
            settings.user_drag_start_callback.call($this, e);

            if (ldist === rdist) {

                if (curX < lleft) {
                    // move the left grip
                    leftGripPositionPx += ldelta;
                    _is_left_grip = true;
                }
                else {
                    // move the right grip
                    rightGripPositionPx += rdelta;
                    _is_left_grip = false;
                }
            }
            else if (ldist < rdist) {

                // move the left grip
                leftGripPositionPx += ldelta;
                _is_left_grip = true;
            }
            else {
                // move the right grip
                rightGripPositionPx += rdelta;
                _is_left_grip = false;
            }

            //
            // Limit the right grip to the maximum allowed - as the user can
            // actually click beyond it!
            //
            // ...............
            //               ^-- maximum clickable
            //              ^--- maximum allowed (i.e., sliderWidth - gripWidth)
            //
            // if user clicks at sliderWidth, we will be setting CSS left of
            // right handle having:
            //
            // ...............R  <-- out of bound :-(
            //               ^-- maximum clickable
            //              ^--- maximum allowed (i.e., sliderWidth - gripWidth)
            //
            // but we want:
            //
            // ..............R <-- within bound :-)
            //               ^-- maximum clickable
            //              ^--- maximum allowed (i.e., sliderWidth - gripWidth)
            //
            // Hence we limit.
            //

            if ($this.data('has_right_grip')) {
                // here we check the right handle only, because it should
                // always be the one that gets moved if the user clicks towards
                // the right extremity!
                if (rightGripPositionPx > sliderWidthPx) {
                    rightGripPositionPx = sliderWidthPx;
                }
            }
            else {
                // in case we have one handle only, we will be moving the left
                // handle instead of the right one... hence we need to perform
                // this check on the left handle as well!
                if (leftGripPositionPx > sliderWidthPx) {
                    leftGripPositionPx = sliderWidthPx;
                }
            }

            // this can happen because the user can click on the left handle!
            // (which is out of the left boundary)
            if (leftGripPositionPx < 0) {
                leftGripPositionPx = 0;
            }
            
            _is_mousedown = true;

            var prev_min = $this.data('cur_min'),
                prev_max = $this.data('cur_max');

            _methods.set_position_from_px.call($this, leftGripPositionPx, rightGripPositionPx);

            // set the style of the grips according to the highlighted range
            _methods.refresh_grips_style.call($this);

            _methods.notify_changed_implicit.call($this, 'drag_start', prev_min, prev_max);

            // no need to call preventDefault on touch events, as we called
            // preventDefault on the original event already
            if (Object.prototype.toString.apply(e) !== "[object Touch]") {
                e.preventDefault();
            }
        },
        'drag_move_func_touch' : function (e) {
            if (_is_mousedown === true) {
                var original_event = e.originalEvent;
                original_event.preventDefault();
                var touch = original_event.touches[0];
                _methods.drag_move_func(touch);
            }
        },
        'drag_move_func' : function (e) {
            if (_is_mousedown) {
                // our slider element.
                var $this = _$current_slider,
                    settings = $this.data('settings'),
                    sliderWidthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width'),
                    leftGripPositionPx = _methods.getLeftGripPositionPx.call($this);

                var rightGripPositionPx = _methods.getRightGripPositionPx.call($this);

                //
                // Here we are going to set the position in pixels based on
                // where the user has moved the mouse cursor. We obtain the
                // position of the mouse cursors via e.pageX, which returns the
                // absolute position of the mouse on the screen.
                //
                var absoluteMousePosition = Math.round(e.pageX);

                //
                // Compute the delta (in px) for the slider movement. It is the
                // difference between the new position of the cursor and the
                // old position of the cursor.
                //
                // Based on the delta we decide how to move the dragged handle.
                //
                // 0 : no movement
                // -delta: move left
                // +delta: move right
                //
                var delta = absoluteMousePosition - _original_mousex;

                //
                // User cannot drag the handles outside the slider bar area.
                //

                // 1) calculate the area within which the movement is
                //    considered to be valid.
                var half_a_grip_width = $this.data('left_grip_width') / 2,
                    drag_area_start = $this.offset().left + $this.data('left_grip_width') - half_a_grip_width,
                    drag_area_end = drag_area_start + sliderWidthPx;

                if (settings.crossable_handles === false && $this.data('has_right_grip')) {
                    // if handles are not crossable, we should define the left
                    // and the right boundary of the movement.
                    if (_is_left_grip) {
                        drag_area_end = drag_area_start + rightGripPositionPx;
                    }
                    else {
                        drag_area_start = drag_area_start + leftGripPositionPx;
                    }
                }
 
                // 2) by default we accept to move the slider according to both
                // the deltas (i.e., left or right)
                var ignore_positive_delta = 0,
                    ignore_negative_delta = 0;
 
                // 3) but if the user is moving the mouse beyond the draggable
                // area, we should only accept a movement in one direction.
                if (absoluteMousePosition < drag_area_start) { 
                    ignore_positive_delta = 1;
                    ignore_negative_delta = 0;
                }
                if (absoluteMousePosition > drag_area_end) {
                    ignore_negative_delta = 1;
                    ignore_positive_delta = 0;
                }

                //
                // Here we decide whether to invert the grip being moved.
                //
                if (settings.crossable_handles === true && 
                    $this.data('has_right_grip')) {

                    if (_is_left_grip) {

                        // ... if we are using the left grip
                        if (rightGripPositionPx <= sliderWidthPx) {

                            // the inversion logic should only be active when the
                            // slider is not at the extremity
                            if (leftGripPositionPx + delta > rightGripPositionPx) {

                                _is_left_grip = false;

                                // TWEAK: keep the position of the left handle fixed
                                // at the one of the right handle as the user may
                                // have moved the mouse too fast, thus giving
                                // leftGripPositionPx > rightGripPositionPx.
                                //
                                // Basically here we avoid:
                                // 
                                // Initial State:
                                //
                                // ------L-R------  (leftGripPositionPx < rightGripPositionPx)
                                //
                                // Fast Mouse Move:
                                //
                                // --------R--L---  (leftGripPositionPx + delta)
                                // --------R-L----  (leftGripPositionPx [ still > rightGripPositionPx! ])
                                //
                                // _is_left_grip becomes false (this code)
                                // 
                                leftGripPositionPx = rightGripPositionPx;
                            }
                        }
                    }
                    else {
                        // ... converse logic
                        if (leftGripPositionPx >= 0) {
                            if (rightGripPositionPx + delta < leftGripPositionPx) {

                                // current_max = current_min;
                                _is_left_grip = true;

                                rightGripPositionPx = leftGripPositionPx;
                            }
                        }
                    }
                }

                //
                // Decide the position of the new handles.
                //
                var nextLeftGripPositionPx = leftGripPositionPx,
                    nextRightGripPositionPx = rightGripPositionPx;

                if ((delta > 0 && !ignore_positive_delta) || 
                    (delta < 0 && !ignore_negative_delta)) {

                    if (_is_left_grip) {
                        nextLeftGripPositionPx += delta;
                    }
                    else {
                        nextRightGripPositionPx += delta;
                    }
                }

                _methods.validateAndMoveGripsToPx.call($this, nextLeftGripPositionPx, nextRightGripPositionPx);
 
                // prepare for next movement
                _original_mousex = absoluteMousePosition;

                
                // no need to call preventDefault on touch events, as we called
                // preventDefault on the original event already
                if (Object.prototype.toString.apply(e) !== "[object Touch]") {
                    e.preventDefault();
                }
            }
        },
        'drag_end_func_touch' : function (e) {
            var original_event = e.originalEvent;
            original_event.preventDefault();
            var touch = original_event.touches[0];
            _methods.drag_end_func(touch);
        },
        'drag_end_func' : function (/* e */) {
            var $this = _$current_slider;
            if (typeof $this !== 'undefined') {
                _is_mousedown = false;
                _original_mousex = undefined;

                _methods.notify_mouse_up_implicit.call($this, _is_left_grip);

                // require another click on a handler before going into here again!
                _$current_slider = undefined;

                // put back the class once user finished dragging
                var settings = $this.data('settings');
                $this.find(settings.left_grip_selector + 
                    ',' + settings.value_bar_selector + 
                    ',' + settings.right_grip_selector).addClass(

                    settings.animating_css_class
                );
            }
        },
        'get_rounding_for_value' : function (v) {
            var $this = this;
            var rounding = $this.data('rounding');
            var rounding_ranges = $this.data('rounding_ranges');

            if (typeof rounding_ranges === 'object') {

                // then it means the rounding is not fixed, we should find the
                // value in the roundings_array.
                var roundingIdx  = _methods.binarySearch.call($this, rounding_ranges, v, 
                    // pick an element from the array
                    function (array, index) { return array[index].range; },

                    // compare search element with current element
                    // < 0 search < current
                    // 0   equals
                    // > 0 search > current
                    function (search, array, currentIdx) {

                        // first check if this is our element

                        // this is our element if the search value is:
                        if (search < array[currentIdx].range) {

                            // we can have a match or search in the left half
                            if (currentIdx > 0) {
                                if (search >= array[currentIdx - 1].range) {
                                    return 0;
                                }
                                else {
                                    // go left
                                    return -1;
                                }
                            }
                            else {
                                return 0;
                            }
                        }
                        else {
                            // we must search in the next half
                            return 1;
                        }
                    }
                );

                rounding = 1;
                if (roundingIdx > -1) {
                    rounding = parseInt(rounding_ranges[roundingIdx].value, 10);
                }
                else {
                    var lastIdx = rounding_ranges.length - 1;
                    if (v >= rounding_ranges[lastIdx].range) {
                        rounding = rounding_ranges[lastIdx].value;
                    }
                }
            }
            return rounding;
        },
        /*
         * Calls the user mouseup callback with the right parameters. Relies on
         * $data('beforestart_min/max') in addition to the isLeftGrip parameter.
         *
         * NOTE: saves the new beforestart_min and begforestart_max as well.
         */
        'notify_mouse_up_implicit' : function(isLeftGrip) {
            var $this = this,
                current_min_value = methods.get_current_min_value.call($this),
                current_max_value = methods.get_current_max_value.call($this),
                didValuesChange = false;

            // check if we changed.
            if (($this.data('beforestart_min') !== current_min_value) || 
                ($this.data('beforestart_max') !== current_max_value)
            ) {
                // values have changed!
                didValuesChange = true;

                // save the new values
                $this.data('beforestart_min', current_min_value);
                $this.data('beforestart_max', current_max_value);
            }


            var settings = $this.data('settings');

            settings.user_mouseup_callback.call($this, 
                methods.get_current_min_value.call($this),
                methods.get_current_max_value.call($this),
                isLeftGrip,
                didValuesChange
            );

            return $this;
        },
        /*
         * NOTE: this method may take the previous min/max value as input.
         *       if no arguments are provided the method blindly notifies.
         */
        'notify_changed_implicit' : function (cause, prevMin, prevMax) {
            var $this = this;

            var force = false;
            if (cause === 'init' || cause === 'refresh') {
                force = true;
            }

            var curMin = methods.get_current_min_value.call($this),
                curMax = methods.get_current_max_value.call($this);

            if (!force) {
                prevMin = methods.round_value_according_to_rounding.call($this, prevMin);
                prevMax = methods.round_value_according_to_rounding.call($this, prevMax);
            }

            if (force || curMin !== prevMin || curMax !== prevMax) {

                _methods.notify_changed_explicit.call($this, cause, prevMin, prevMax, curMin, curMax);

                force = 1;
            }

            return force;
        },
        'notify_changed_explicit' : function (cause, prevMin, prevMax, curMin, curMax) {
            var $this = this,
                settings = $this.data('settings');

            // maybe update aria attributes for accessibility
            if ($this.data('aria_enabled')) {
                _methods.updateAriaAttributes.call($this);
            }

            settings.value_changed_callback.call($this, cause, curMin, curMax, prevMin, prevMax);

            return $this;
        },
        'validate_params' : function (settings) {
            var $this = this;
            var min_value = $this.data('range_min'),
                max_value = $this.data('range_max'),
                cur_min = $this.data('cur_min'),
                lower_limit = $this.data('lower-limit'),
                upper_limit = $this.data('upper-limit');

            var have_limits = _methods.haveLimits.call($this);

            if (typeof min_value === 'undefined') {
                $.error("the data-range_min attribute was not defined");
            }
            if (typeof max_value === 'undefined') {
                $.error("the data-range_max attribute was not defined");
            }
            if (typeof cur_min === 'undefined') {
                $.error("the data-cur_min attribute must be defined");
            }
            if (min_value > max_value) {
                $.error("Invalid input parameter. must be min < max");
            }

            if (have_limits && lower_limit > upper_limit) {
                $.error('Invalid data-lower-limit or data-upper-limit');
            }
            if ($this.find(settings.left_grip_selector).length === 0) {
                $.error("Cannot find element pointed by left_grip_selector: " + settings.left_grip_selector);
            }
            /* 
             * NOTE: only validate right grip selector if it is not
             * undefined otherwise just assume that if it isn't
             * found isn't there. This is because we initialize the
             * slider at once and let the markup decide if the
             * slider is there or not.
             */
            if (typeof settings.right_grip_selector !== 'undefined') {
                if ($this.find(settings.right_grip_selector).length === 0) {
                    $.error("Cannot find element pointed by right_grip_selector: " + settings.right_grip_selector);
                }
            }

            // same thing for the value bar selector
            if (typeof settings.value_bar_selector !== 'undefined') {
                if ($this.find(settings.value_bar_selector).length === 0) {
                    $.error("Cannot find element pointed by value_bar_selector" + settings.value_bar_selector);
                }
            }
        },
        /*
         * Maps a value between [minRange -- maxRange] into [0 -- n].
         * The target range will be an integer number.
         */
        'rangemap_0_to_n' : function (val, n) {
            var $this = this;
            var rangeMin = $this.data('range_min');
            var rangeMax = $this.data('range_max');

            if (val <= rangeMin) { return 0; }
            if (val >= rangeMax) { return n; }

            return Math.floor((n * val - n * rangeMin) / (rangeMax - rangeMin));
        },
        /*
         * Maps a value between [0 -- max] back into [minRange -- maxRange].
         * The target range can be a floating point number.
         */
        'inverse_rangemap_0_to_n' : function (val, max) {
            var $this = this;
            var rangeMin = $this.data('range_min');
            var rangeMax = $this.data('range_max');

            if (val <= 0)   { return rangeMin; }
            if (val >= max) { return rangeMax; }

            //
            // To do this we first map 0 -- max relatively withing [minRange
            // and maxRange], that is between [0 and (maxRange-minRange)].
            //
            var relativeMapping = (rangeMax - rangeMin) * val / max;

            // ... then we bring this to the actual value by adding rangeMin.
            return relativeMapping + rangeMin;
        }

    };
    var methods = {
        
        'teardown' : function () {
            var $this = this;

            // remove all data set with .data()
            $this.removeData();

            // unbind the document as well
            $(document)
                .unbind('mousemove.nstSlider')
                .unbind('mouseup.nstSlider');

            // unbind events bound to the container element
            $this.parent()
                .unbind('mousedown.nstSlider')
                .unbind('touchstart.nstSlider')
                .unbind('touchmove.nstSlider')
                .unbind('touchend.nstSlider');
            
            // unbind events bound to the current element
            $this.unbind('keydown.nstSlider')
                .unbind('keyup.nstSlider');

            return $this;
        },
        'init' : function(options) {
            var settings = $.extend({
                'animating_css_class' : 'nst-animating',
                // this is the distance from the value bar by which we should
                // grab the left or the right handler.
                'touch_tolerance_value_bar_y': 30,  // px
                'touch_tolerance_value_bar_x': 15,  // px
                // where is the left grip?
                'left_grip_selector': '.nst-slider-grip-left',
                // where is the right grip?
                // undefined = (only left grip bar)
                'right_grip_selector': undefined,

                // Specify highlight like this if you want to highlight a range
                // in the slider.
                //
                // 'highlight' : {
                //     'grip_class' : '.nsti-slider-hi',
                //     'panel_selector' : '.nst-slider-highlight-panel'
                // },
                'highlight' : undefined,

                // Lets you specify the increment rounding for the slider handles
                // for when the user moves them.
                // It can be a string, indicating a fixed increment, or an object
                // indicating the increment based on the value to be rounded.
                //
                // This can be specified in the following form: {
                //    '1' : '100',    
                //    '10' : '1000',  /* rounding = 10 for values in [100-999] */
                //    '50' : '10000',
                // }
                'rounding': undefined,

                // if the bar is not wanted
                'value_bar_selector': undefined,

                // Allow handles to cross each other while one of them is being
                // dragged. This option is ignored if just one handle is used.
                'crossable_handles': true,

                'value_changed_callback': function(/*cause, vmin, vmax*/) { return; },
                'user_mouseup_callback' : function(/*vmin, vmax, left_grip_moved*/) { return; },
                'user_drag_start_callback' : function () { return; }
            }, options);

            //
            // we need to unbind events attached to the document,
            // as if we replace html elements and re-initialize, we
            // don't want to double-bind events!
            //
            var $document = $(document);

            // make sure only one event is bound to the document
            $document.unbind('mouseup.nstSlider');
            $document.unbind('mousemove.nstSlider');

            $document.bind('mousemove.nstSlider', _methods.drag_move_func);
            $document.bind('mouseup.nstSlider',   _methods.drag_end_func);

            return this.each(function() {
                //
                // $this is like:
                //
                // <div class="outer-slider" data-... data-...>
                //     <div class="bar"></div>
                //     <div class="leftGrip"></div>
                //     <div class="rightGrip"></div>
                // </div>
                //
                // It is supposed to be enclosed in a container
                //
                var $this = $(this),
                    $container = $this.parent();

                // enable: the user is able to move the grips of this slider.
                $this.data('enabled', true);

                // fix some values first
                var rangeMin = $this.data('range_min'),
                    rangeMax = $this.data('range_max'),
                    valueMin = $this.data('cur_min'),
                    valueMax = $this.data('cur_max');

                // assume 0 if valueMax is not specified
                if (typeof valueMax === 'undefined') {
                    valueMax = valueMin;
                }

                if (rangeMin === '') { rangeMin = 0; }
                if (rangeMax === '') { rangeMax = 0; }
                if (valueMin === '') { valueMin = 0; }
                if (valueMax === '') { valueMax = 0; }

                $this.data('range_min', rangeMin);
                $this.data('range_max', rangeMax);
                $this.data('cur_min', valueMin);
                $this.data('cur_max', valueMax);

                // halt on error
                _methods.validate_params.call($this, settings);

                $this.data('settings', settings);

                // override rounding from markup if defined in configuration
                if (typeof settings.rounding !== 'undefined') {
                    methods.set_rounding.call($this, settings.rounding);
                }
                else if (typeof $this.data('rounding') !== 'undefined') {
                    methods.set_rounding.call($this, $this.data('rounding'));
                }
                else {
                    methods.set_rounding.call($this, 1);
                }
                
                var left_grip = $this.find(settings.left_grip_selector)[0],
                    $left_grip = $(left_grip),
                    $right_grip = $($this.find(settings.right_grip_selector)[0]);

                // make sure left grip can be tabbed if the user hasn't
                // defined their own tab index
                if (typeof $left_grip.attr('tabindex') === 'undefined') {
                    $left_grip.attr('tabindex', 0);
                }

                // no right handler means single handler
                var has_right_grip = false;
                if ($this.find(settings.right_grip_selector).length > 0) {
                    has_right_grip = true;

                    // make sure right grip can be tabbed if the user hasn't
                    // defined their own tab index
                    if (typeof $right_grip.attr('tabindex') === 'undefined') {
                        $right_grip.attr('tabindex', 0);
                    }
                }
                $this.data('has_right_grip', has_right_grip);

                // enable aria attributes update?
                if ($this.data('aria_enabled') === true) {
                    // setup aria role attributes on each grip
                    $left_grip
                        .attr('role', 'slider')
                        .attr('aria-disabled', 'false');

                    if (has_right_grip) {
                        $right_grip
                            .attr('role', 'slider')
                            .attr('aria-disabled', 'false');
                    }
                }

                //
                // deal with keypresses here
                //
                $this.bind('keyup.nstSlider', function (e) {
                    if ($this.data('enabled')) {
                        switch (e.which) {
                            case 37:   // left
                            case 38:   // up
                            case 39:   // right 
                            case 40:   // down

                            if (_before_keydown_value === _before_keyup_value) {

                                // we should search for the next value change...
                                // ... in which direction? depends on whe

                                var searchUntil = _methods.getSliderWidthPx.call($this),
                                    val,
                                    i,
                                    setAtPixel;

                                if (_before_keydown_pixel - _before_keyup_pixel < 0) {
                                    // the grip was moved towards the right

                                    for (i=_before_keyup_pixel; i<=searchUntil; i++) {
                                        // if the value at pixel i is different than
                                        // the current value then we are good to go.
                                        //
                                        val = methods.round_value_according_to_rounding.call($this,
                                            _methods.getSliderValuesAtPositionPx.call($this, i, i)[1]
                                        );
                                        if (val !== _before_keyup_value) {
                                            setAtPixel = i;
                                            break;
                                        }
                                    }
                                }
                                else {
                                    // the grip was moved towards the left

                                    for (i=_before_keyup_pixel; i>=0; i--) {

                                        // if the value at pixel i is different than
                                        // the current value then we are good to go.
                                        //
                                        val = methods.round_value_according_to_rounding.call($this,
                                            _methods.getSliderValuesAtPositionPx.call($this, i, i)[1]
                                        );
                                        if (val !== _before_keyup_value) {
                                           setAtPixel = i;
                                           break;
                                        }
                                    }
                                }


                                // we need to set the slider at this position
                                if (_is_left_grip) {
                                    _methods.validateAndMoveGripsToPx.call($this, setAtPixel, _methods.getRightGripPositionPx.call($this));
                                }
                                else {
                                    _methods.validateAndMoveGripsToPx.call($this, _methods.getLeftGripPositionPx.call($this), setAtPixel);
                                }

                                //
                                // call the mouseup callback when the key is up!
                                //
                                _methods.notify_mouse_up_implicit.call($this, _is_left_grip);
                            }
                        }

                        // clear values 
                        _before_keydown_value = undefined;
                        _before_keydown_pixel = undefined;
                        _before_keyup_value = undefined;
                        _before_keyup_pixel = undefined;
                    }
                });
                $this.bind('keydown.nstSlider', function (evt) {
                    if ($this.data('enabled')) {

                        var moveHandleBasedOnKeysFunc = function ($grip, e) {

                            var nextLeft = _methods.getLeftGripPositionPx.call($this),
                                nextRight = _methods.getRightGripPositionPx.call($this);

                            if (typeof _before_keydown_value === 'undefined') {
                                _before_keydown_pixel = _is_left_grip ? nextLeft : nextRight;

                                _before_keydown_value = _is_left_grip ? methods.get_current_min_value.call($this) : methods.get_current_max_value.call($this);
                            }

                            switch (e.which) {
                                case 37:   // left
                                case 40:   // down
                                    if (_is_left_grip) { nextLeft--; } else { nextRight--; }
                                    e.preventDefault();
                                    break;

                                case 38:   // up
                                case 39:   // right 
                                    if (_is_left_grip) { nextLeft++; } else { nextRight++; }

                                    e.preventDefault();
                                    break;
                            }

                            _before_keyup_pixel = _is_left_grip ?  nextLeft : nextRight;

                            // may write into cur_min, cur_max data...
                            _methods.validateAndMoveGripsToPx.call($this, nextLeft, 
                                nextRight);

                            _before_keyup_value = _is_left_grip ? methods.get_current_min_value.call($this) : methods.get_current_max_value.call($this);
                        };
                        
                        // default
                        if (has_right_grip && $this.find(':focus').is($right_grip)) {
                            _is_left_grip = false;
                            moveHandleBasedOnKeysFunc.call($this, $right_grip, evt);
                        }
                        else {
                            _is_left_grip = true;
                            moveHandleBasedOnKeysFunc.call($this, $left_grip, evt);
                        }
                    } 
                });

                // determine size of grips
                var left_grip_width = _methods.getLeftGripWidth.call($this),
                    right_grip_width = has_right_grip ? 
                        _methods.getRightGripWidth.call($this) : left_grip_width;

                $this.data('left_grip_width', left_grip_width);
                $this.data('right_grip_width', right_grip_width);

                $this.data('value_bar_selector', settings.value_bar_selector);

                // set behaviour of naked bar in case of one handle
                if (!has_right_grip) {
                    var bStickToSides = valueMax === rangeMax || valueMax === rangeMin;
                    _methods.setNakedBarDelta.call($this,
                        bStickToSides ? "stickToSides" : "middle",
                        left_grip_width
                    );
                }

                // this will set the range to the right extreme in such a case.
                if (rangeMin === rangeMax || valueMin === valueMax) {
                    methods.set_range.call($this, rangeMin, rangeMax);
                }
                else {

                    // set the initial position
                    _methods.set_position_from_val.call($this, 
                        $this.data('cur_min'), $this.data('cur_max'));
                }

                _methods.notify_changed_implicit.call($this, 'init');

                // handle mouse movement
                $this.data('beforestart_min', methods.get_current_min_value.call($this));
                $this.data('beforestart_max', methods.get_current_max_value.call($this));

                // pass a closure, so that 'this' will be the current slider bar,
                // not the container.
                $this.bind('mousedown.nstSlider', function (e) {
                    _methods.drag_start_func.call($this, e, settings, $left_grip, $right_grip, false);
                });
                
                $container.bind('touchstart.nstSlider', function (e) {
                    _methods.drag_start_func_touch.call($this, e, settings, $left_grip, $right_grip, true);
                });
                $container.bind('touchend.nstSlider',  function (e) {
                    _methods.drag_end_func_touch.call($this, e);
                });
                $container.bind('touchmove.nstSlider', function (e) {
                    _methods.drag_move_func_touch.call($this, e);
                });

                // if the data-histogram attribute exists, then use this
                // histogram to set the step distribution
                var step_histogram = $this.data('histogram');
                if (typeof step_histogram !== 'undefined') {
                    methods.set_step_histogram.call($this, step_histogram);
                }
            }); // -- each slider
        },
        'get_range_min' : function () {
            var $this = this;
            return $this.data('range_min');
        },
        'get_range_max' : function () {
            var $this = this;
            return $this.data('range_max');
        },
        'get_current_min_value' : function () {
            var $this = $(this);

            var rangeMin = methods.get_range_min.call($this),
                rangeMax = methods.get_range_max.call($this);

            var currentMin = $this.data('cur_min');

            var min;
            if (rangeMin >= currentMin) {
                min = rangeMin;
            }
            else {
                min = methods.round_value_according_to_rounding.call($this, currentMin);
            }

            if (_methods.haveLimits.call($this)) {
                if (min <= rangeMin) {
                    return $this.data('lower-limit');
                }
                else if (min >= rangeMax) {
                    return $this.data('upper-limit');
                }
            }
            else {
                if (min <= rangeMin) {
                    return rangeMin;
                }
                else if (min >= rangeMax) {
                    return rangeMax;
                }
            }

            return min;
        },
        'get_current_max_value' : function () {
            var $this = $(this);

            var rangeMin = methods.get_range_min.call($this),
                rangeMax = methods.get_range_max.call($this);

            var currentMax = $this.data('cur_max');

            var max;
            if (rangeMax <= currentMax) {
                max = rangeMax;
            }
            else {
                max = methods.round_value_according_to_rounding.call($this, currentMax);
            }


            if (_methods.haveLimits.call($this)) {
                if (max >= rangeMax) {
                    return $this.data('upper-limit');
                }
                else if (max <= rangeMin) {
                    return $this.data('lower-limit');
                }
            }
            else {
                if (max >= rangeMax) {
                    return rangeMax;
                }
                else if (max <= rangeMin) {
                    return rangeMin;
                }
            }

            return max;
        },
        'is_handle_to_left_extreme' : function () {
            var $this = this; 
            if (_methods.haveLimits.call($this)) {
                return $this.data('lower-limit') === methods.get_current_min_value.call($this);
            }
            else {
                return methods.get_range_min.call($this) === methods.get_current_min_value.call($this);
            }
        },
        'is_handle_to_right_extreme' : function () {
            var $this = this; 
            if (_methods.haveLimits.call($this)) {
                return $this.data('upper-limit') === methods.get_current_max_value.call($this);
            }
            else {
                return methods.get_range_max.call($this) === methods.get_current_max_value.call($this);
            }
        },
        // just call set_position on the current values
        'refresh' : function () {
            var $this = this;

            // re-set the slider step if specified
            var lastStepHistogram = $this.data('last_step_histogram');
            if (typeof lastStepHistogram !== 'undefined') {
                methods.set_step_histogram.call($this, lastStepHistogram); 
            }

            // re-center given values
            _methods.set_position_from_val.call($this, 
                methods.get_current_min_value.call($this),
                methods.get_current_max_value.call($this)
            );

            // re-highlight the range
            var highlightRangeMin = $this.data('highlightedRangeMin');
            if (typeof highlightRangeMin === 'number') {
                // a highlight range is present, we must update it
                var highlightRangeMax = $this.data('highlightedRangeMax');
                methods.highlight_range.call($this, highlightRangeMin, highlightRangeMax);
            }

            _methods.notify_changed_implicit.call($this, 'refresh');
            return $this;
        },
        'disable' : function () {
            var $this = this,
                settings = $this.data('settings');

            $this.data('enabled', false)
                .find(settings.left_grip_selector)
                    .attr('aria-disabled', 'true')
                .end()
                .find(settings.right_grip_selector)
                    .attr('aria-disabled', 'true');

            return $this;
        },
        'enable' : function() {
            var $this = this,
                settings = $this.data('settings');

            $this.data('enabled', true)
                .find(settings.left_grip_selector)
                    .attr('aria-disabled', 'false')
                .end()
                .find(settings.right_grip_selector)
                    .attr('aria-disabled', 'false');

            return $this;
        },
        'is_enabled' : function() {
            var $this = this;
            return $this.data('enabled');
        },
        /*
         * This one is the public method, called externally.
         * It sets the position and notifies in fact.
         */
        'set_position' : function(min, max) {
            var $this = this;

            var prev_min = $this.data('cur_min'),
                prev_max = $this.data('cur_max');

            if (min > max) {
                _methods.set_position_from_val.call($this, max, min);
            }
            else {
                _methods.set_position_from_val.call($this, min, max);
            }

            // set the style of the grips according to the highlighted range
            _methods.refresh_grips_style.call($this);

            _methods.notify_changed_implicit.call($this, 'set_position', prev_min, prev_max);
            
            // this is for the future, therefore "before the next
            // interaction starts"
            $this.data('beforestart_min', min);
            $this.data('beforestart_max', max);
        },
        /*
         * This tells the slider to increment its step non linearly over the
         * current range, based on the histogram on where results are.
         *
         * the input parameter 'histogram' identifies an empirical probability
         * density function (PDF).
         *
         */
        'set_step_histogram' : function (histogram) {
            var $this = this;

            $this.data('last_step_histogram', histogram);

            if (typeof histogram === 'undefined') {
                $.error('got an undefined histogram in set_step_histogram');
                _methods.unset_step_histogram.call($this);
            }

            var sliderWidthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width'),
                nbuckets = histogram.length;

            if (sliderWidthPx <= 0) {
                // that means the slider is not visible...
                return;
            }

            //
            // we need to transform this pdf into a cdf, and use it to obtain
            // two mappings: pixel to value and value to pixel.
            //
            // 1) normalize the pdf to sum to sliderWidthPx first
            var i;
            var histogram_sum = 0;
            for (i=0; i<nbuckets; i++) {
                histogram_sum += histogram[i]; 
            }

            //
            // if the sum of the histogram is 0 it means that all is 0 in the 
            // histogram! (i.e, flat histogram). In this case we already know
            // what's going to be the answer...
            //
            if (histogram_sum === 0) {
                // ... and the answer is: a linear scale between min_range and
                // max range!
                methods.unset_step_histogram.call($this);

                return $this;
            }

            // coefficient for normalization
            var coeff = parseFloat(histogram_sum)/sliderWidthPx;

            // go normalize the histogram using this coefficient!
            for (i=0; i<nbuckets; i++) {
                histogram[i] = histogram[i]/coeff;
            }

            // 2) now that the histogram is normalized, extract the cumulative
            // distribution function (CDF). This is an always increasing function
            // that ranges between 0 and sliderWidthPx;
            //
            // We also build the inverted cdf, just the cdf read the other way
            // around.
            //
            var cdf = [ histogram[0] ];  // points to pixels
            for (i=1; i<nbuckets; i++) {
                var cdf_x = cdf[i-1] + histogram[i];
                cdf.push(cdf_x);
            }
            cdf.push(sliderWidthPx);


            // the first value here is always min_range as the cdf is supposed
            // to start from 0 (also first pixel = min_range)
            var pixel_to_value_lookup = [ $this.data('range_min') ];

            var last_filled = 0; // we've already filled 0

            // now stretch over the rest of the cdf
            var last_price_for_cdf_bucket = pixel_to_value_lookup[0];

            var cdf_bucket_count = 0;
            while (last_filled <= sliderWidthPx) { // do until all pixels are filled

                // get next item from cdf
                var fill_up_to_px = parseInt(cdf.shift(), 10);
                var price_for_cdf_bucket = 
                    _methods.inverse_rangemap_0_to_n.call($this, cdf_bucket_count+1, nbuckets+1);

                cdf_bucket_count++;

                // how many pixels do we have to fill
                var fill_tot = fill_up_to_px - last_filled;

                // interpolate and fill
                var diff = price_for_cdf_bucket - last_price_for_cdf_bucket;
                for (i = last_filled; i < fill_up_to_px; i++) {
                    var next_price_for_cdf_bucket = 
                        last_price_for_cdf_bucket + (diff * (i-last_filled+1) / fill_tot);

                    pixel_to_value_lookup.push(next_price_for_cdf_bucket);

                    last_filled++;

                    last_price_for_cdf_bucket = next_price_for_cdf_bucket;
                }

                if (last_filled === sliderWidthPx) {
                    break;
                }
            }
            pixel_to_value_lookup[pixel_to_value_lookup.length-1] = $this.data('range_max');

            // 3) build lookup functions to extract pixels and values from the
            // cdf and the inverted cdf.
            //
            var pixel_to_value_mapping = function (pixel) {
                return pixel_to_value_lookup[parseInt(pixel, 10)];
            };

            var value_to_pixel_mapping = function (value) {
                //
                // Binary search into the array of pixels, returns always the
                // rightmost pixel if there is no exact match.
                //
                var suggestedPixel = _methods.binarySearch.call($this, pixel_to_value_lookup, value, 
                    function(a, i) { return a[i]; },  // access a value in the array
                    _methods.binarySearchValueToPxCompareFunc
                );

                // exact match
                if (pixel_to_value_lookup[suggestedPixel] === value) {
                    return suggestedPixel;
                }

                // approx match: we need to check if it's closer to the value
                // at suggestedPixel or the value at suggestedPixel-1
                if ( Math.abs(pixel_to_value_lookup[suggestedPixel-1] - value) <
                     Math.abs(pixel_to_value_lookup[suggestedPixel] - value) ) {

                     return suggestedPixel-1;
                }
                return suggestedPixel;
            };

            //
            // these two functions will be stored and then used internally to
            // decide what value to display given a certain pixel, and what
            // pixel to put the slider on given a certain value.
            //
            $this.data('pixel_to_value_mapping', pixel_to_value_mapping);
            $this.data('value_to_pixel_mapping', value_to_pixel_mapping);

            return $this;
        },
        /*
         * Remove the pixel-to-value and the value-to-pixel mappings from the
         * slider so that the slider can follow a linear step over the current
         * range again.
         */
        'unset_step_histogram' : function () {
            var $this = this;

            $this.removeData('pixel_to_value_mapping');
            $this.removeData('value_to_pixel_mapping');
            $this.removeData('last_step_histogram');

            return $this;
        },
        'set_range' : function (rangeMin, rangeMax) {
            var $this = this;

            // get the current values
            var oldMin = methods.get_current_min_value.call($this),
                oldMax = methods.get_current_max_value.call($this);
            
            // set range
            $this.data('range_min', rangeMin);
            $this.data('range_max', rangeMax);

            // try to re-center old values in the new range.
            // NOTE: this may set different values!
            _methods.set_position_from_val.call($this, oldMin, oldMax);

            /*
             * Re-highlight ranges if any are defined.
             */
            // var highlightRangeMin = $this.data('highlightedRangeMin');
            // if (typeof rangeMin === 'number') {
            //     // a highlight range is present, we must update it
            //     var highlightRangeMax = $this.data('highlightedRangeMax');
            //     methods.highlight_range.call($this, highlightRangeMin, highlightRangeMax);
            // }

            // pass old min and max in the notify_changed_implicit method, so that we
            // notify if we need to
            _methods.notify_changed_implicit.call($this, 'set_range', oldMin, oldMax);

            return $this;
        },
        /*
         * This method highlights the range of the slider apart from the
         * position of the slider grips.
         * To work well, the slider must have background color set to
         * transparent in the CSS or not set.
         */
        'highlight_range' : function(rangeMin, rangeMax) {
            var $this = this;
            var settings = $this.data('settings');

            if (typeof settings.highlight === "undefined") {
                $.error('you cannot call highlight_range if you haven\' specified the "highlight" parameter in construction!');
            }

            // avoid empty string
            if (!rangeMin) { rangeMin = 0; }
            if (!rangeMax) { rangeMax = 0; }

            // we need to map rangeMin and rangeMax into pixels.
            var leftPx = methods.value_to_px.call($this, rangeMin),
                rightPx = methods.value_to_px.call($this, rangeMax),
                barWidth = rightPx - leftPx + $this.data('left_grip_width');

            // set position
            var $highlightPanel = $this.find(
                settings.highlight.panel_selector
            );

            $highlightPanel.css('left', leftPx + "px");
            $highlightPanel.css('width', barWidth + "px");

            // keep the latest highlighted range, because if set_range is called
            // we must be able to update the highlighting.
            $this.data('highlightedRangeMin', rangeMin);
            $this.data('highlightedRangeMax', rangeMax);

            // now decide wether the handler should be highlight
            _methods.refresh_grips_style.call($this);

            return $this;
        },
        /*
         * Sets the increment rounding for the slider, see input parameters section
         * for more information.
         */
        'set_rounding' : function (rounding) {
            var $this = this;

            if (typeof rounding === 'string' && rounding.indexOf('{') > -1) {
                // probably a json string
                rounding = $.parseJSON(rounding);
            }

            $this.data('rounding', rounding);
            
            // build an array of roundings and sort it by value to facilitate search
            // when the range is going to be set.
            var roundings_array = [];
            if (typeof rounding === 'object') {
                // initial object has the form { value : range }
                var rounding_value;
                for (rounding_value in rounding) { // skip_javascript_test
                    if (rounding.hasOwnProperty(rounding_value)) {
                        var rounding_range = rounding[rounding_value];
                        roundings_array.push({ 
                            'range' : rounding_range, 
                            'value' : rounding_value 
                        });
                    }
                }

                // now sort it by rounding range
                roundings_array.sort(function (a, b) { return a.range - b.range; });

                $this.data('rounding_ranges', roundings_array);
            }
            else {
                $this.removeData('rounding_ranges');
            }

            return $this;
        },
        'get_rounding' : function () {
            var $this = this;
            return $this.data('rounding');
        },
        /*
         * This method rounds a given value to the closest integer defined
         * according to the rounding. Examples:
         * rounding: 10 v: 12.3    --> 10
         * rounding: 1 v: 12.3     --> 12
         * rounding: 10 v: 12.6    --> 13
         */
        'round_value_according_to_rounding' : function(v) {
            var $this = this;
            var rounding = _methods.get_rounding_for_value.call($this, v);

            if (rounding > 0) {
                // We bring ourselves in a space of unitary roundings. You can
                // imagine now that sliders range between a certain minimum and 
                // maximum, and we always increase/decrease of one.
                var increment = v / rounding;

                // This is the proposed value.
                var increment_int = parseInt(increment, 10);

                // delta is a positive number between 0 and 1 that tells us how
                // close is the slider to integer + 1 (i.e., the next rounding).
                // 0 means the grip is exactly on integer
                // 1 means the grip is on integer + 1.
                var delta = increment - increment_int;

                // now use delta to modify or not the current value.
                if (delta > 0.5) {
                    increment_int++; 
                }

                // we now move the 
                var rounded = increment_int * rounding;

                return rounded;
            }
            else {
                $.error('rounding must be > 0, got ' + rounding + ' instead');
            }
            return v;
        },
        /*
         * Utility function. Given a value within the range of the slider,
         * converts the value in pixels. If a value_to_pixel_mapping function
         * is defined it will be used, otherwise a linear mapping is used for
         * the conversion.
         */
        'value_to_px' : function (value) {
            var $this = this,
                value_to_pixel_mapping_func = $this.data('value_to_pixel_mapping');

            // try using non-linear mapping if it's there...
            if (typeof value_to_pixel_mapping_func !== 'undefined') {
                return value_to_pixel_mapping_func(value); 
            }

            // ... use linear mapping otherwise
            var w = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width');
            return _methods.rangemap_0_to_n.call($this, value, w);
        }
    };

    var __name__ = 'nstSlider';

    $.fn[__name__] = function(method) {
        /*
         * Just a router for method calls
         */
        if (methods[method]) {
            if (this.data('initialized') === true) {
                // call a method
                return methods[method].apply(this,
                    Array.prototype.slice.call(arguments, 1)
                );
            }
            else {
                throw new Error('method ' + method + ' called on an uninitialized instance of ' + __name__);
            }
        }
        else if (typeof method === 'object' || !method) {
            // call init, user passed the settings as parameters
            this.data('initialized', true);
            return methods.init.apply(this, arguments);
        }
        else {
            $.error('Cannot call method ' + method);
        }
    };
})(jQuery);

/**
* Smoke form validation and components for Bootstrap
* @package Smoke
* @version 3.0
* @link https://github.com/alfredobarron/smoke The Smoke GitHub project
* @author Alfredo Barron <alfredobarronc@gmail.com>
* @copyright 2015 Alfredo Barron
* @license https://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
* @note This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
*/

(function($) {
  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Validate all inputs
  * if($('#form').smkValidate()){}
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.fn.smkValidate = function() {

    var settings = $.extend({}, $.fn.smkValidate.Languaje);

    var languaje = $.fn.smkValidate.Languaje;

    if (languaje === undefined) {

      languaje =  {
        // Mensaje de error para los input vac√≠os
        textEmpty        : 'Required field',
        // Mensaje de error para el input email
        textEmail        : 'Enter a valid email',
        // Mensaje de error para el input alphanumeric
        textAlphanumeric : 'Only numbers and/or letters allowed',
        // Mensaje de error para el input number
        textNumber       : 'Only numbers are allowed',
        // Mensaje de error para el input number range
        textNumberRange  : 'The numerical range must be greater than <b> {@} </b> and less than <b> {@} </b>',
        // Mensaje de error para el input decimal
        textDecimal      : 'Only decimal numbers are allowed',
        // Mensaje de error para el input currency
        textCurrency     : 'Please enter a valid monetary amount',
        // Mensaje de error para el input select
        textSelect       : 'It is necessary that you select an option',
        // Mensaje de error para el input checkbox y radio
        textCheckbox     : 'It is necessary that you select an option',
        // Mensaje de error para longitud de caracteres
        textLength       : 'The number of characters is equal to <b> {@} </b>',
        // Mensaje de error para rango de caracteres
        textRange        : 'The number of characters must be greater than <b> {@} </b> and less than <b> {@} </b>',
        // Mensaje de error para strongPass Default
        textSPassDefault : 'Minimum 4 characters',
        // Mensaje de error para strongPass Weak
        textSPassWeak    : 'Minimum 6 characters',
        // Mensaje de error para strongPass Madium
        textSPassMedium  : 'Minimum 6 characters and a number',
        // Mensaje de error para strongPass Strong
        textSPassStrong  : 'Minimum 6 characters a number and a capital',
        textUrl          : 'Please enter a valid url',
        textTel          : 'Please enter a valid phone number',
        textColor        : 'Please enter a valid hex color',
        textDate         : 'Please enter a valid date',
        textDatetime     : 'Please enter a valid date and time',
        textMonth        : 'Please enter a valid month',
        textWeek         : 'Please enter a valid week',
        textTime         : 'Please enter a valid time',
        textPattern      : 'Enter a valid string'
      };
    }

    // Se agrega el attr novalidate al form
    if (this.is('form')) {
      this.attr('novalidate', 'novalidate');
    }

    // Se inicializan las variables globales
    var result = true;

    // Se obtienen todos los inputs
    var inputs = (this.is(':input')) ? $(this) : $(':input:not(:button):not(:disabled):not(.novalidate)', this);

    // Se recorren todos los inputs del formulario
    inputs.each(function(k,v) {
      // Se obtiene el objeto input
      var input = $(v);
      // Se obtiene el type
      var type = $(v).attr('type');
      // Se obtiene el type smk
      var smkType = $(v).attr('data-smk-type');
      // Se obtiene el tag
      var tag = v.tagName.toLowerCase();
      // Se obtiene el value
      var value = $(v).val();
      // Se obtiene el name
      var name = $(v).attr('name');
      // Se obtiene el attr requerido
      var required = $(v).attr('required');
      // Se obtiene el valor de longitud menor aceptada
      var minlength = $(v).attr('minlength');
      // Se obtiene el valor de longitud mayor aceptada
      var maxlength = $(v).attr('maxlength');
      // Se obtiene el valor de longitud menor aceptada
      var smkMin = $(v).attr('data-smk-min');
      // Se obtiene el valor de longitud mayor aceptada
      var smkMax = $(v).attr('data-smk-max');
      // Se obtiene el nivel de la fuerza de la contrase√±a
      var smkStrongPass = $(v).attr('data-smk-strongPass');
      // Se obtiene el pattern de una expresi√≥n regular
      var smkPattern = $(v).attr('data-smk-pattern');
      // Se obtiene el valor pesta√±a centavos
      var smkDecimalSeparator = $(v).attr('data-smk-decimal-separator');
      // Se obtiene el valor pesta√±a miles
      var smkThousandSeparator = $(v).attr('data-smk-thousand-separator');

      //Obtiene las fichas de los valores por defecto de miles y centavos
      if (typeof(smkDecimalSeparator) === 'undefined'){
        //Valor por defecto
        smkDecimalSeparator = '.'; //Default
      }
      if (typeof(smkThousandSeparator) === 'undefined'){
        //Valor por defecto
        smkThousandSeparator = ','; //Default
      }

      // Se eliminan los mensajes de error
      $.smkRemoveError(input);

      // Se obtiene el value de los input RADIO y/o CHECKBOX
      if (type === 'radio' || type === 'checkbox') {
        // Se obtiene el value del grupo de checks o radios
        //value = $("input[name=" + name + "]:checked").val();
        value = $("input[name='" + name + "']:checked").val();
      }

      // Se validan los INPUTS que son requeridos y estan vacios
      if (required === 'required' && (value === '' || value === undefined)) {
        // Se agrega el mensaje de error
        result =  $.smkAddError(input, languaje.textEmpty);
      }

      // Si el input no esta vacio
      if (value !== '') {

        // Se valida el input EMAIL
        if (type === 'email') {
          //Se crea la expresi√≥n regular para el input mail
          var emailRegex = /^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!emailRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textEmail);
          }
        }

        // Se valida el input ALPHANUMERIC
        if (smkType === 'alphanumeric') {
          // Se crea la expresi√≥n regular para el input alphanumeric
          var alphanumericRegex = /^[a-z0-9]+$/i;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!alphanumericRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, languaje.textAlphanumeric);
          }
        }

        // Se valida el input NUMBER
        if (type === 'number' || smkType === 'number') {
          // Se crea la expresi√≥n regular para el input number
          var numberRegex = /^\d+$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!numberRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, languaje.textNumber);
          } else {

            // Se valida el input NUMBER RANGE
            if ((typeof(smkMin) !== 'undefined' || typeof(smkMax) !== 'undefined')) {
              if((value < smkMin) || (value > smkMax)){
                var arrayTextNumberRange = [];
                arrayTextNumberRange[0] = parseInt(smkMin-1);
                arrayTextNumberRange[1] = parseInt(smkMax)+1;
                var textNumberRange = $.smokeCustomizeMsg(languaje.textNumberRange, arrayTextNumberRange);
                // Se agrega el mensaje de error
                result = $.smkAddError(input, textNumberRange);
              }
            }

          }
        }

        // Se valida el input DECIMAL
        if (smkType === 'decimal') {
          // Se crea la expresi√≥n regular para el input decimal
          //var decimalRegex = /^\d+(?:\.\d{1,4})?$/;
          var decimalRegex = (smkDecimalSeparator === ',') ? (/^\d+(?:\,\d{1,4})?$/) :  (/^\d+(?:\.\d{1,4})?$/);
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!decimalRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, languaje.textDecimal);
          }
        }

        // Se valida el input CURRENCY
        if (smkType === 'currency') {
          // Se crea la expresi√≥n regular para el input currency con $ al inicio
          //var currencyRegex = /^\$?(?:\d+|\d{1,3}(?:,\d{3})*)(?:\.\d{1,2}){0,1}$/;
          // Se crea la expresi√≥n regular para el input currency
          //var currencyRegex = /^(?:\d+|\d{1,3}(?:,\d{3})*)(?:\.\d{1,4}){0,1}$/;
          var currencyRegex = (smkDecimalSeparator === ',' && smkThousandSeparator === '.') ? (/^(?:\d+|\d{1,3}(?:.\d{3})*)(?:\,\d{1,4}){0,1}$/) : (/^(?:\d+|\d{1,3}(?:,\d{3})*)(?:\.\d{1,4}){0,1}$/) ;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!currencyRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, languaje.textCurrency);
          }
        }

        // Se valida el input longitud o rango de caracteres MINLENGTH o MAXLENGTH
        if ((typeof(minlength) !== 'undefined' || typeof(maxlength) !== 'undefined')) {
          // Si contiene ambos y son iguales
          if (minlength === maxlength) {
            if ((value.length != minlength) && (value.length != maxlength)) {
              // Se personaliza el mensaje de error
              var textLength = $.smokeCustomizeMsg(languaje.textLength, maxlength);
              // Se agrega el mensaje de error
              result = $.smkAddError(input, textLength);
            }
            // Si contiene ambos y son diferentes
          } else if (minlength !== maxlength) {
            if ((value.length < minlength) || (value.length > maxlength)) {
              var arrayTextRange = [];
              arrayTextRange[0] = parseInt(minlength-1);
              arrayTextRange[1] = parseInt(maxlength)+1;
              // Se personaliza el mensaje de error
              var textRange = $.smokeCustomizeMsg(languaje.textRange, arrayTextRange);
              // Se agrega el mensaje de error
              result = $.smkAddError(input, textRange);
            }
          }
        }

        // Se valida el input PASSWORD
        if (type === 'password') {
          var strongPassRegex = '';
          var textPass = '';
          // Se obtiene el nivel de fuerza de la contrase√±a
          switch (smkStrongPass) {
            case ('weak'):// Debe contener al menos 4 caracteres
            strongPassRegex = /^(?=.*[a-z0-9])\w{6,}$/;
            textPass = languaje.textSPassWeak;
            break;
            case ('medium'):// Debe contener al menos 6 caracteres y un numero
            strongPassRegex = /^(?=.*\d)(?=.*[a-z])\w{6,}$/;
            textPass = languaje.textSPassMedium;
            break;
            case ('strong'):// Debe contener al menos 6 caracteres, un numero y una may√∫scula
            strongPassRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])\w{6,}$/;
            textPass = languaje.textSPassStrong;
            break;
            default:// Debe contener al menos 4 caracteres
            strongPassRegex = /^(?=.*[a-z0-9])\w{4,}$/;
            textPass = languaje.textSPassDefault;
          }
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!strongPassRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, textPass);
          }
        }

        // Se valida el input URL
        if (type === 'url') {
          //Se crea la expresi√≥n regular para el input url
          var urlRegex = /^(http|ftp|https):\/\/[\w-]+(\.[\w-]+)*([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!urlRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textUrl);
          }
        }

        // Se valida el input TEL
        if (type === 'tel') {
          //Se crea la expresi√≥n regular para el input tel
          var telRegex = /^(\+?)\d{10,15}$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!telRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textTel);
          }
        }

        // Se valida el input COLOR
        if (type === 'color') {
          //Se crea la expresi√≥n regular para el input color
          var colorRegex = /^#([0-9a-f]{3}){1,2}$/i;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!colorRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textColor);
          }
        }

        // Se valida el input DATE
        if (type === 'date') {
          //Se crea la expresi√≥n regular para el input date
          var dateRegex = /^([0-9]{4})-(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!dateRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textDate);
          }
        }

        // Se valida el input DATETIME
        if (type === 'datetime') {
          //Se crea la expresi√≥n regular para el input datetime
          var datetimeRegex = /^([0-9]{4})-(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])T(2[0-3]|[0-1][0-9]):([0-5][0-9]):([0-5][0-9])(Z|[+-](?:2[0-3]|[0-1][0-9]):[0-5][0-9])?$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!datetimeRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textDatetime);
          }
        }

        // Se valida el input MONTH
        if (type === 'month') {
          //Se crea la expresi√≥n regular para el input month
          var monthRegex = /^([0-9]{4})-(1[0-2]|0[1-9])$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!monthRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textMonth);
          }
        }

        // Se valida el input WEEK
        if (type === 'week') {
          //Se crea la expresi√≥n regular para el input week
          var weekRegex = /^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!weekRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textWeek);
          }
        }

        // Se valida el input TIME
        if (type === 'time') {
          //Se crea la expresi√≥n regular para el input time
          var timeRegex = /^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])(:([0-5]?[0-9]))?$/;
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!timeRegex.test(value)) {
            // Se agrega el mensaje de error
            result =  $.smkAddError(input, languaje.textTime);
          }
        }

        // Se valida el pattern de una expresi√≥n regular
        if (smkPattern !== '' && smkPattern !== undefined) {
          // Se valida que el value del input cumpla con la expresi√≥n regular
          var patternRegex = new RegExp('^(' + smkPattern + ')$');
          // Se valida que el value del input cumpla con la expresi√≥n regular
          if (!patternRegex.test(value)) {
            // Se agrega el mensaje de error
            result = $.smkAddError(input, languaje.textPattern);
          }
        }

      }

      input
      .off('.validation') // remove all events in namespace validation
      .on('keyup.validation change.validation click.validation', function(e) {
        // Check for validation
        $(this).smkValidate();
      });

    });

    // Se posiciona el focus en el primer input con error
    this.find('.form-group.has-feedback.has-error').first().find(':input:not(:button):not(:disabled):not(.novalidate)').first().focus();

    //Se retorna el resultado
    return result;
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Validate Equal passwords
  * if($.smkEqualPass('#password', '#repassword')){}
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkEqualPass = function(password, repassword) {

    // Se crea el mensaje de error para el input repassword
    var languaje = $.smkEqualPass.Languaje;

    if (languaje === undefined) {
      languaje =  {
        textEqualPass: 'Passwords do not match'
      };
    }

    if($(password).val() !== undefined){
      password = $(password).val();
    }else{
      password = password;
    }

    // Si los password son diferentes se retorna false
    if (password !== $(repassword).val()) {
      // Se agrega el mensaje de error
      return $.smkAddError($(repassword), languaje.textEqualPass);
      // Si los passwords son iguales se retorna true
    } else {
      return true;
    }

  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Clear form
  * $('#form').smkClear();
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.fn.smkClear = function() {

    // Se obtienen todos los inputs
    var inputs = (this.is(':input')) ? $(this) : $(':input:not(:button)', this);

    // Se recorren todos los inputs del formulario
    inputs.each(function(k,v) {

      // Se eliminan los mensajes de error
      $.smkRemoveError(v);

      // Si el input no contiene el attr data-smk-noclear
      if ( $(v).attr('data-smk-noclear') === undefined ) {
        //Se obtiene el type y el tag del input
        var type = this.type;
        var tag = this.tagName.toLowerCase();
        //Si el tag trae el valor 'input' se sustituye por el valor type
        if (tag == 'input') {
          tag = type;
        }
        //Se compara el type y se limpia
        switch (type) {
          case 'text':
          case 'password':
          case 'email':
          case 'number':
          case 'hidden':
          case 'date':
          case 'datetime':
          case 'datetime-local':
          case 'month':
          case 'week':
          case 'time':
          case 'tel':
          case 'url':
          case 'search':
          case 'range':
          case 'color':
            this.value = '';
          break;
          case 'checkbox':
          case 'radio':
            this.checked = false;
          break;
        }
        //Se compara el tag y se limpia
        switch (tag) {
          case 'textarea':
            this.value = '';
          break;
          case 'select':
            this.selectedIndex = 0;
            if($(this).hasClass('select2')){
              //$(this).select2('val', '');
              // new version
              $(this).val('').trigger("change.select2");
            }
          break;
        }
      }
    });
    //$(this)[0].reset();
  };






  /*
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  |   Se crea el m√©todo que agrega el mensaje de error
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkAddError = function (obj, message)
  {
    // Se obtiene el icono
    var icon = $(obj).parents('form').attr('data-smk-icon');
    // Se obtiene el elemento form-group
    var formGroup = $(obj).parents('.form-group');
    // Se obtiene el elemento padre
    var parent = $(obj).parent();
    // Se obtiene el type
    var type = $(obj).attr('type');
    // Se obtiene el mensaje de error
    var smkMsg = $(obj).attr('data-smk-msg');
    // Se crea el template del icono de error
    var ico = '<span class="glyphicon '+ icon +' form-control-feedback smk-error-icon"></span>';

    // Si type es indefinido se asigna el nombre del tag
    if(type === undefined) type = $(obj).prop('tagName').toLowerCase();

    // Si el form no contiene icono
    if (icon === '' || icon === undefined) ico = '';

    // Si el input no contiene mensaje de error se asigna uno
    if (smkMsg === '' || smkMsg === undefined) smkMsg = message;

    // Se crea el template del mensaje de error
    var msg = '<span class="help-block smk-error-msg">' + smkMsg + '</span>';

    if(type == 'select'){
      // Se agrega la clase de error
      formGroup.addClass('has-feedback has-error smk-' + type);
      // Se agrega el icono y el mensaje de error
      formGroup.append(ico + msg);
    }else if(type == 'checkbox' || type == 'radio'){
      // Se agrega la clase de error
      formGroup.addClass('has-feedback has-error smk-' + type);
      // Se agrega el icono y el mensaje de error
      formGroup.append(msg);
    }else{
      // Se agrega la clase de error
      formGroup.addClass('has-feedback has-error');
      // Si el form tiene la clase form-horizontal
      if (formGroup.parent().hasClass('form-horizontal')) {
        // Se agrega el icono y el mensaje de error
        parent.append(ico + msg);
      } else {
        // Se agrega el icono y el mensaje de error
        formGroup.append(ico + msg);
      }
    }

    // Se retorna false
    return false;
  };
  /*
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  |   Se crea el m√©todo que remueve el mensaje de error
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkRemoveError = function(obj)
  {
    // Se obtiene el elemento padre
    var parent = $(obj).parents('.form-group');
    // Se remueven el icono y el mensaje de error
    parent.find('.smk-error-msg, .smk-error-icon').remove();
    // Se remueve la clase de error
    parent.removeClass('has-error has-feedback');
    // Se retorna false
    return false;
  };
  /*
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  |   Se crea el m√©todo que personaliza los mensaje de error
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smokeCustomizeMsg = function(msg, arrayMsg){
    var customMsg = '';
    if(typeof(arrayMsg) == 'string'){
      customMsg = msg.replace('{@}', arrayMsg);
    }else{
      var split = msg.split('{@}');
      $.each(arrayMsg, function(index, val) {
        customMsg += split[index] + val;
      });
      customMsg += split[split.length - 1];
    }
    return customMsg;
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Alerts
  * $.smkAlert({
  *   text: 'Hello world',
  *   icon: 'glyphicon-time',
  *   position: 'top-right'
  *   type: 'success',
  *   time: 5,
  *   permanent: false
  * });
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  // Se crea la funcion smkAlert
  $.smkAlert = function(options) {

    // Variables default
    var settings = $.extend({
      text: 'Hola Mundo',
      type: 'warning',
      icon: '',
      position: 'top-right',
      time: 5,
      permanent: false
    }, options);

    var smk_alert_content_class = 'smk-alert-content';
    var available_positions = ['top-left', 'top-center', 'top-right', 'bottom-left', 'bottom-center', 'bottom-right'];

    if ($.inArray(settings.position, available_positions) >= 0){
      smk_alert_content_class += '-' + settings.position;
    }

    // Se compara el tipo de alerta y se asigna la clase
    switch (settings.type) {
      case 'warning':
      settings.type = 'alert-warning';
      if (settings.icon === '') settings.icon = 'glyphicon-exclamation-sign';
      break;
      case 'success':
      settings.type = 'alert-success';
      if (settings.icon === '') settings.icon = 'glyphicon-ok-sign';
      break;
      case 'danger':
      settings.type = 'alert-danger';
      if (settings.icon === '') settings.icon = 'glyphicon-remove-sign';
      break;
      case 'info':
      settings.type = 'alert-info';
      if (settings.icon === '') settings.icon = 'glyphicon-info-sign';
      break;
    }

    // Se agrega el contenedor de las alertas en el body
    if(!$('body > .' + smk_alert_content_class).length) {
      $('body').append('<div class="smk-alert-content ' + smk_alert_content_class + '"></div>');
    }
    // Se crea la alerta en el contenedor
    var obj = $('<div class="alert alert-dismissable ' + settings.type + ' smk-alert"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><span class="glyphicon ' + settings.icon + '"></span><p>' + settings.text + '</p></div>');

    $('.' + smk_alert_content_class).prepend(obj);

    // Se aplica la animaci√≥n de entrada a la alerta
    obj.animate({
      opacity: '1',
    }, 300);

    // Si el mensaje no es permanente
    if(settings.permanent === false){
      var timer = 0;
      // Si se posiciona el cursor en la alerta se restablece el TimeOut
      $(obj).mouseenter(function(){
        clearTimeout(timer);
        // Si sale el cursor de la alerta se ejecuta el m√©todo smkAlertHide
      }).mouseleave(function(){
        smkAlertHide();
      });

      smkAlertHide();
    }

    // Se crea el m√©todo que elimina la alerta del contenedor
    function smkAlertHide(){
      timer = setTimeout(function() {
        obj.animate({
          opacity: '0',
        }, 300, function() {
          obj.remove();
        });
      }, (settings.time * 1000) );
    }

  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Confirmation
  * $.smkConfirm({
  *   text: 'are you sure?',
  *   accept: 'Accept',
  *   cancel: 'Cancel'
  * },function(e){
  *   if(res){
  *     // Code here
  *   }
  * });
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkConfirm = function(options, callback) {
    // Variables default
    var settings = $.extend({
      text: 'are you sure?',
      accept: 'Accept',
      cancel: 'Cancel'
    }, options);
    // Se agrega el panel de confirmacion en el body
    $('body').append('<div class="smk-confirm-back"><div class="panel panel-default smk-confirm" tabindex="1"><div class="panel-body">' + settings.text + '</div><div class="panel-footer text-right"><a class="btn btn-default btn-sm smk-cancel" href="#" >' + settings.cancel + '</a> <a class="btn btn-primary btn-sm smk-accept" href="#">' + settings.accept + '</a></div></div></div>');
    // Se aplica la animacion de entrada del panel de confirmacion
    $('.smk-confirm').animate({
      top: "-5px",
      opacity: '1'
    }, 400, function(){
      $('.smk-confirm').focus();
    }).on('keydown', function(e) {
      if (e.which === 27) {
        $('.smk-cancel').click();
      } else if (e.which === 13) {
        if (!$('.smk-accept').is(":focus"))
        $('.smk-accept').click();
      }
    });
    // Si se presiona el boton .smk-cancel se retorna false
    $('.smk-cancel').click(function(e) {
      e.preventDefault();
      smkConfirmHide();
      //return false;
      callback(false);
    });
    // Si se presiona el boton .smk-accept se retorna true
    $('.smk-accept').click(function(e) {
      e.preventDefault();
      smkConfirmHide();
      //return true;
      callback(true);
    });
    // Se remueve el panel de confirmacion del body
    function smkConfirmHide(){
      $('.smk-confirm-back').fadeOut(200, function() {
        $('.smk-confirm-back').remove();
      });
      $('.smk-confirm').animate({
        top: "-500px",
        opacity: '0'
      }, 400, function() {
        $('.smk-confirm').remove();
      });
    }
  };





  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Prompt
  * $.smkPrompt({
  *   text: 'What is your name?',
  *   defaultValue: '',
  *   accept: 'Accept',
  *   cancel: 'Cancel'
  * },function(res){
  *   if(res){
  *     // Code here
  *   } else {
  *    // Code here
  *   }
  * });
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkPrompt = function(options, callback) {
    // Variables default
    var settings = $.extend({
      text: 'Enter value',
      defaultValue: '',
      accept: 'Accept',
      cancel: 'Cancel'
    }, options);
    // Se agrega el panel de confirmacion en el body
    $('body').append('<div class="smk-confirm-back"><div class="panel panel-default smk-prompt" tabindex="1"><div class="panel-body"><div class="form-group"><label for="smkPromptInput">' + settings.text + '</label><input class="form-control" id="smkPromptInput" autocomplete="off" type="text" value="' + settings.defaultValue + '"></div></div><div class="panel-footer text-right"><a class="btn btn-default btn-sm smk-cancel" href="#" >' + settings.cancel + '</a> <a class="btn btn-primary btn-sm smk-accept" href="#">' + settings.accept + '</a></div></div></div>');
    // Se aplica la animacion de entrada del panel de confirmacion
    $('.smk-prompt').animate({
      top: "-5px",
      opacity: '1'
    }, 400, function(){
      $('.smk-prompt input[type="text"]').focus().select();
    }).on('keydown', function(e) {
      if (e.which === 27) {
        $('.smk-cancel').click();
      } else if (e.which === 13) {
        if (!$('.smk-accept').is(":focus"))
        $('.smk-accept').click();
      }
    });
    // Si se presiona el boton .smk-cancel se retorna false
    $('.smk-cancel').click(function(e) {
      e.preventDefault();
      smkConfirmHide();
      //return false;
      callback(false);
    });
    // Si se presiona el boton .smk-accept se retorna true or false
    $('.smk-accept').click(function(e) {
      e.preventDefault();
      smkConfirmHide();
      //return the value;
      var ret = ($('.smk-prompt input').val() !== '') ? $('.smk-prompt input').val() : false;
      callback(ret);
    });
    // Se remueve el panel de confirmacion del body
    function smkConfirmHide(){
      $('.smk-confirm-back').fadeOut(200, function() {
        $('.smk-confirm-back').remove();
      });
      $('.smk-prompt').animate({
        top: "-500px",
        opacity: '0'
      }, 400, function() {
        $('.smk-prompt').remove();
      });
    }
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Float
  * var float = $.smkFloat('1,0000.00');
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkFloat = function(number) {
    if(typeof number === 'string'){
      number = number.replace(',', '');
    }
    return parseFloat(number);
  };





  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Currency
  * var currency = $.smkCurrency(10000, '$');
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkCurrency = function(number, prefix) {
    if (typeof number !== 'string') {
      number = number.toString();
    }
    var num = number.replace(',', '');
    if(num !== ''&& !isNaN(num)){
      num = Math.round(parseFloat(num) * Math.pow(10, 2)) / Math.pow(10, 2);
      prefix = prefix || '';
      num += '';
      var splitStr = num.split('.');
      var splitLeft = splitStr[0];
      var splitRight = splitStr.length > 1 ? '.' + splitStr[1] : '.00';
      splitRight = splitRight + '00';
      splitRight = splitRight.substr(0, 3);
      var regx = /(\d+)(\d{3})/;
      while (regx.test(splitLeft)) {
        splitLeft = splitLeft.replace(regx, '$1' + ',' + '$2');
      }
      return prefix + splitLeft + splitRight;
    }else{
      return 0;
    }
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * GetURL
  * var url = $.smkGetURL(1);
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkGetURL = function(folder) {
    //Se obtiene el protocolo http o https
    var protocol = $(location).attr('protocol');
    //Se obtiene el nombre del servidor o dominio
    var hostname = $(location).attr('hostname');
    //Se obtiene la o las subcarpetas
    var pathname = $(location).attr('pathname');
    //Se explota el pathname para obtener todos sus elementos separados por /
    pathname = pathname.split('/');
    //Se obtiene el ultimo elemento
    var last = pathname.pop();
    //Si el ultimo elemento no esta vacio
    if (last !== '') {
      //Se explota el ultimo elemento
      file = last.split('.');
      //Si el ultimo elemento no es un archivo
      if (file.length < 2) {
        //Se agrega el ultimo elemento
        pathname.push(last);
      }
    }
    //Se dejan unicamente el numero de folders que se obtienen de la variable folders
    pathname = pathname.slice(0, folder + 1);
    //Se unen los elementos de el pathname separados por /
    pathname = pathname.join('/');
    //Se unen los elementos que forman la url
    var url = protocol + '//' + hostname + pathname;
    //Se retorna la url
    return url;
  };





  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * ShowPass
  * $('.panel').smkShowPass();
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.fn.smkShowPass = function(options) {

    var self = $(this);
    var parent = self.parent('.form-group');
    var btnShow = '<span class="glyphicon glyphicon-eye-open smk-btn-show-pass" aria-hidden="true"></span>';

    parent.addClass('smk-show-pass');
    parent.append( btnShow );

    // Evento del boton Remove
    parent.find('.smk-btn-show-pass').click(function(event) {
      event.preventDefault();
      if (self.prop('type') == 'password') {
        self.prop('type', 'text');
        $(this).addClass('glyphicon-eye-close');
        $(this).removeClass('glyphicon-eye-open');
      } else {
        self.prop('type', 'password');
        $(this).removeClass('glyphicon-eye-close');
        $(this).addClass('glyphicon-eye-open');
      }
    });

  };




  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Hide email
  * var email = $.smkHideEmail('alfredobarronc@gmail.com');
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkHideEmail = function(string) {
    var parts = string.split('@');
    var first = parts[0].charAt(0);
    var last = parts[0].slice(-1);
    var arterisk = '';
    for (var i = 0; i < parts[0].length - 2; i++) {
      arterisk = arterisk + '*';
    }
    var email = first + arterisk + last + '@' + parts[1];
    return email;
  };





  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * DatePicker
  * var date = $.smkDatePicker( $('.datepicker').datepicker('getDate') );
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkDatePicker = function(date) {

    if(date !== ''){
      // Se obtiene el dia
      var day   = (date.getDate() < 10 ? '0' : '') + date.getDate();
      // Se obtiene el mes
      var month = ((date.getMonth() + 1) < 10 ? '0' : '') + (date.getMonth() + 1);
      // Se obtiene el a√±o
      var year = date.getFullYear();
      // Se construye la fecha con el formato para BD yyyy-mm-dd
      result = year + '-' + month + '-' + day;
    }else{
      result = '';
    }

    // Se retorna la fecha formateada
    return result;
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Date
  * var date = $.smkDate({date:new Date(), format:'yyyy-mm-dd' });
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkDate = function(options) {
    var today = $.smkDatePicker( new Date() );
    var settings = $.extend({
      date: today,
      format: 'yyyy-mm-dd'
    }, $.smkDate.Languaje, options);

    var languaje = $.smkDate.Languaje;

    if (languaje === undefined) {
      languaje =  {
        shortMonthNames : ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        monthNames : ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
      };
    }
    //Se obtienen los separadores
    var validDate = /\d+|[a-zA-z]/g;
    var separator = settings.date.replace(validDate, '\0').split('\0');
    // Se obtiene las partes de la fecha
    var splitDate = settings.date.match(validDate);

    if(settings.lang == 'es'){
      // Se formatea la fecha (yyyy,mm,dd) para poder instanciar el m√©todo new Date()
      if(splitDate[0].length == 4){
        // Formato yyyy-mm-dd => yyyy,mm,dd
        settings.date = new Date(splitDate[0],(splitDate[1]-1),splitDate[2]);
      }else{
        // Formato dd-mm-yyyy => yyyy,mm,dd
        settings.date = new Date(splitDate[2],(splitDate[1]-1),splitDate[0]);
      }
    }else{
      // Se formatea la fecha (yyyy,mm,dd) para poder instanciar el m√©todo new Date()
      if(splitDate[0].length == 4){
        // Formato yyyy-dd-mm => yyyy,mm,dd
        settings.date = new Date(splitDate[0],(splitDate[2]-1),splitDate[1]);
      }else{
        // Formato mm-dd-yyyy => yyyy,mm,dd
        settings.date = new Date(splitDate[2],(splitDate[0]-1),splitDate[1]);
      }
    }

    var result = '';

    if(settings.date != 'Invalid Date'){

      // Se crea el array que contiene el d√≠a, mes y a√±o
      var arrayDate = {
        // Se obtiene el dia
        'd'    : settings.date.getDate(),
        'dd'   : (settings.date.getDate() < 10 ? '0' : '') + settings.date.getDate(),
        // Se obtiene el mes
        'm'    : settings.date.getMonth() + 1, //January is 0!
        'mm'   : ((settings.date.getMonth() + 1) < 10 ? '0' : '') + (settings.date.getMonth() + 1),
        'M'    : languaje.shortMonthNames[settings.date.getMonth()],
        'MM'   : languaje.monthNames[settings.date.getMonth()],
        // Se obtiene el a√±o
        'yyyy' : settings.date.getFullYear(),
        // Se obtiene el a√±o 2 digitos
        'yy'   : settings.date.getFullYear().toString().substring(2),
        // Se obtiene la hora
        'hh'   : settings.date.getHours(),
        // Se obtienen los minutos
        'mi'   : settings.date.getMinutes(),
        // Se obtienen los segundos
        'ss'   : settings.date.getSeconds()
      };

      // Se obtienen los separadores
      var validFormat = /dd?|DD?|mm?|MM?|yy(?:yy)?/g;
      var separators = settings.format.replace(validFormat, '\0').split('\0');
      // Se obtienen las partes del formato
      var splitFormat = settings.format.match(validFormat);

      // Se construye la fecha con el formato y los separadores indicados
      $.each(splitFormat, function(key, val) {
        result += separators[key] + arrayDate[val];
      });

    }else{
      result = '';
      console.log('Invalid Date');
    }

    // Se retorna la fecha formateada
    return result;
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * DateDiff
  * var dif = $.smkDateDiff({fromDate:'01/01/2013 12:00:00', toDate:'12/31/2014 12:30:00', interval:'days'});
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkDateDiff = function(options) {
    //Variables default
    var settings = $.extend({
      fromDate: new Date(),
      toDate: new Date(),
      interval: 'days'
    }, options);
    var second = 1000,
    minute = second * 60,
    hour = minute * 60,
    day = hour * 24,
    week = day * 7;
    var fromDate = new Date(settings.fromDate);
    var toDate = new Date(settings.toDate);
    var timediff = toDate - fromDate;
    if (isNaN(timediff)) return NaN;
    switch (settings.interval) {
      case "years":
      return toDate.getFullYear() - fromDate.getFullYear();
      case "months":
      return ((toDate.getFullYear() * 12 + toDate.getMonth()) - (fromDate.getFullYear() * 12 + fromDate.getMonth()));
      case "weeks":
      return Math.floor(timediff / week);
      case "days":
      return Math.floor(timediff / day);
      case "hours":
      return Math.floor(timediff / hour);
      case "minutes":
      return Math.floor(timediff / minute);
      case "seconds":
      return Math.floor(timediff / second);
      default:
      return undefined;
    }
  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Scrolling
  * $.smkScrolling({speed:1000});
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkScrolling = function(options) {
    //Variables default
    var settings = $.extend({
      speed: 1000
    }, options);
    $('a[href*=#]:not([href=#])').click(function() {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
        if (target.length) {
          $('html,body').animate({
            scrollTop: target.offset().top
          }, settings.speed);
          return false;
        }
      }
    });
  };





  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * ProgressBar
  * $.smkProgressBar({
  *   element:'body',
  *   status:'start',
  *   bgColor:'#fff',
  *   barColor:'#000',
  *   content:'Loading...'
  * });
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.smkProgressBar = function(options) {
    //Variables default
    var settings = $.extend({
      element: 'body',
      status: 'start',
      bgColor: '#fff',
      barColor: '',
      content: ''
    }, options);

    if(settings.status == 'start'){
      // Se crea el template de la progressbar
      var progressbar = '<div class="smk-progressbar">';
      progressbar +='<div class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"><span class="sr-only">0% Complete</span></div></div>';
      progressbar += '<div class="smk-progressbar-content">' + settings.content + '</div>';
      progressbar += '</div>';

      // Se carga la progressbar al dom
      //$(settings.element).prepend($(progressbar).fadeIn('fast'));
      $(settings.element).prepend($(progressbar));

      $('.smk-progressbar').css('background-color', settings.bgColor);

      $('.smk-progressbar .progress-bar').css('background-color', settings.barColor);

      if(settings.element == 'body'){
        $('.smk-progressbar').css('position', 'fixed');
      }else{
        $(settings.element).css('position', 'relative');
        $('.smk-progressbar').css('position', 'absolute');
      }
      // Se comienza a simular el progreso de la carga de la pagina
      $(settings.element +' .smk-progressbar .progress .progress-bar').width((50 + Math.random() * 30) + '%');

    }else if(settings.status ==  'end'){
      // Se completa el progreso de carga
      $(settings.element +' .smk-progressbar .progress .progress-bar').width('110%').delay(200, function(){
        // Se remueve la progressbar del dom
        $(settings.element +' .smk-progressbar').fadeOut('slow', function() { $(this).remove(); });
      });
    }

  };






  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Fullscreen
  * $('div').smkFullscreen();
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.fn.smkFullscreen = function() {

    // Se crea el boton fullscreen
    var btnFullscreen = '<a class="btn smk-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen" aria-hidden="true"></span></a>';

    // Se agrega el boton fullscreen en el elemento
    $(this).append(btnFullscreen);

    // Evento del boton fullscreen
    $('.smk-fullscreen').click(function(event) {
      event.preventDefault();
      toggleFullScreen();
    });

    // Se crea el metodo que dispara el fullscreen
    function toggleFullScreen() {
      if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement ) {  // current working methods
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
          document.documentElement.msRequestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) {
          document.documentElement.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }

    // Se crea el metodo que cambia el icono del boton
    var changeFullscreen = function(){
      $('.smk-fullscreen').children('.glyphicon').toggleClass('glyphicon-fullscreen').toggleClass('glyphicon-resize-small');
    };

    // Se escuchan los cambios del fullscreen
    document.addEventListener("fullscreenchange", changeFullscreen, false);
    document.addEventListener("msfullscreenchange", changeFullscreen, false);
    document.addEventListener("mozfullscreenchange", changeFullscreen, false);
    document.addEventListener("webkitfullscreenchange", changeFullscreen, false);
  };




  /**
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  * Panel
  * $('.panel').smkPanel({hide: 'min,remove,full', class: 'name-class'});
  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  */
  $.fn.smkPanel = function(options) {
    // Variables default
    var settings = $.extend({
      hide: ''
    }, options);
    var thisPanel = $(this);
    // Se eliminan los espacios en blanco de la variable settings.hide
    var hideSinEspacios = settings.hide.replace(/\s/g, '');
    // Se quiebra la variable hideSinEspacios para obtener sus valores y se agregan en el array arrayHide
    var arrayHide = hideSinEspacios.split(',');
    // Se obtiene el .panel-title de cada panel
    var panelHeading = $(this).children('.panel-heading');
    if (!panelHeading.length){
      panelHeading = $("<div>", {class: 'panel-heading'});
      $(this).prepend(panelHeading);
    }
    var panelTitle = panelHeading.children('.panel-title');
    panelHeading.addClass('clearfix');
    if(panelTitle.length){
      panelTitle.addClass('pull-left');
    }

    // Se crea el btn-group
    var btnGroup = '<div class="btn-group btn-group-xs pull-right" role="group">';
    // Se valida que no exista en el array el boton min para poder agregarlo dentro de btnGroup
    if($.inArray('min', arrayHide) == -1){
      btnGroup += '<a class="btn smk-min" href="#"><span class="glyphicon glyphicon-minus" aria-hidden="true"></span></a>';
    }
    // Se valida que no exista en el array el boton remove para poder agregarlo dentro de btnGroup
    if($.inArray('remove', arrayHide) == -1){
      btnGroup += '<a class="btn smk-remove" href="#"><span class="glyphicon glyphicon-remove" aria-hidden="true"></span></a>';
    }
    // Se valida que no exista en el array el boton full para poder agregarlo dentro de btnGroup
    if($.inArray('full', arrayHide) == -1){
      btnGroup += '<a class="btn smk-full" href="#"><span class="glyphicon glyphicon-resize-full" aria-hidden="true"></span></a>';
    }
    btnGroup += '</div>';

    // Se inserta dentro de .panel-heading
    $(this).children('.panel-heading').append( btnGroup );

    // Evento del boton Min
    thisPanel.find('.smk-min').click(function(event) {
      event.preventDefault();
      var body = $(this).parents('.panel-heading').siblings('.panel-body');
      var footer = $(this).parents('.panel-heading').siblings('.panel-footer');
      var icon = $(this).children('.glyphicon');
      $(footer).slideToggle('fast');
      $(body).slideToggle('fast', function(){
        icon.toggleClass('glyphicon-minus').toggleClass('glyphicon-plus');
      });

    });
    // Evento del boton Remove
    thisPanel.find('.smk-remove').click(function(event) {
      event.preventDefault();
      var panel = $(this).parents('.panel');
      panel.fadeOut(400, function(){
        //this.remove();
      });
    });
    // Evento del boton Full
    thisPanel.find('.smk-full').click(function(event) {
      event.preventDefault();
      var panel = $(this).parents('.panel');
      var body = $(this).parents('.panel-heading').siblings('.panel-body');
      var icon = $(this).children('.glyphicon');
      var iconPlus = $(this).siblings('.btn').children('.glyphicon-plus');

      if(panel.hasClass('panel-full')){
        panel.removeClass('panel-full');
        $(this).siblings('.btn').show();
        if(iconPlus.length == 1){
          body.hide();
        }
        $('body').css({'overflow':'auto'});
        // $('.container-fluid').css({'display':'block'});
        // $('#content').css({'position':'fixed'});
      }else{
        panel.addClass('panel-full');
        $(this).siblings('.btn').hide();
        if(iconPlus.length == 1){
          body.show();
        }
        $('body').css({'overflow':'hidden'});
        // $('.container-fluid').css({'display':'initial'});
        // $('#content').css({'position':'initial'});
      }
      icon.toggleClass('glyphicon-resize-full').toggleClass('glyphicon-resize-small');
    });
  };


})(jQuery);
/*!
 * Lightbox v2.9.0
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright 2007, 2015 Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 *
 * @preserve
 */

// Uses Node, AMD or browser globals to create a module.
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals (root is window)
        root.lightbox = factory(root.jQuery);
    }
}(this, function ($) {

  function Lightbox(options) {
    this.album = [];
    this.currentImageIndex = void 0;
    this.init();

    // options
    this.options = $.extend({}, this.constructor.defaults);
    this.option(options);
  }

  // Descriptions of all options available on the demo site:
  // http://lokeshdhakar.com/projects/lightbox2/index.html#options
  Lightbox.defaults = {
    albumLabel: 'Image %1 of %2',
    alwaysShowNavOnTouchDevices: false,
    fadeDuration: 600,
    fitImagesInViewport: true,
    imageFadeDuration: 600,
    // maxWidth: 800,
    // maxHeight: 600,
    positionFromTop: 50,
    resizeDuration: 700,
    showImageNumberLabel: true,
    wrapAround: false,
    disableScrolling: false,
    /*
    Sanitize Title
    If the caption data is trusted, for example you are hardcoding it in, then leave this to false.
    This will free you to add html tags, such as links, in the caption.

    If the caption data is user submitted or from some other untrusted source, then set this to true
    to prevent xss and other injection attacks.
     */
    sanitizeTitle: false
  };

  Lightbox.prototype.option = function(options) {
    $.extend(this.options, options);
  };

  Lightbox.prototype.imageCountLabel = function(currentImageNum, totalImages) {
    return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
  };

  Lightbox.prototype.init = function() {
    var self = this;
    // Both enable and build methods require the body tag to be in the DOM.
    $(document).ready(function() {
      self.enable();
      self.build();
    });
  };

  // Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
  // that contain 'lightbox'. When these are clicked, start lightbox.
  Lightbox.prototype.enable = function() {
    var self = this;
    $('body').on('click', 'a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]', function(event) {
      self.start($(event.currentTarget));
      return false;
    });
  };

  // Build html for the lightbox and the overlay.
  // Attach event handlers to the new DOM elements. click click click
  Lightbox.prototype.build = function() {
    var self = this;
    $('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));

    // Cache jQuery objects
    this.$lightbox       = $('#lightbox');
    this.$overlay        = $('#lightboxOverlay');
    this.$outerContainer = this.$lightbox.find('.lb-outerContainer');
    this.$container      = this.$lightbox.find('.lb-container');
    this.$image          = this.$lightbox.find('.lb-image');
    this.$nav            = this.$lightbox.find('.lb-nav');

    // Store css values for future lookup
    this.containerPadding = {
      top: parseInt(this.$container.css('padding-top'), 10),
      right: parseInt(this.$container.css('padding-right'), 10),
      bottom: parseInt(this.$container.css('padding-bottom'), 10),
      left: parseInt(this.$container.css('padding-left'), 10)
    };

    this.imageBorderWidth = {
      top: parseInt(this.$image.css('border-top-width'), 10),
      right: parseInt(this.$image.css('border-right-width'), 10),
      bottom: parseInt(this.$image.css('border-bottom-width'), 10),
      left: parseInt(this.$image.css('border-left-width'), 10)
    };

    // Attach event handlers to the newly minted DOM elements
    this.$overlay.hide().on('click', function() {
      self.end();
      return false;
    });

    this.$lightbox.hide().on('click', function(event) {
      if ($(event.target).attr('id') === 'lightbox') {
        self.end();
      }
      return false;
    });

    this.$outerContainer.on('click', function(event) {
      if ($(event.target).attr('id') === 'lightbox') {
        self.end();
      }
      return false;
    });

    this.$lightbox.find('.lb-prev').on('click', function() {
      if (self.currentImageIndex === 0) {
        self.changeImage(self.album.length - 1);
      } else {
        self.changeImage(self.currentImageIndex - 1);
      }
      return false;
    });

    this.$lightbox.find('.lb-next').on('click', function() {
      if (self.currentImageIndex === self.album.length - 1) {
        self.changeImage(0);
      } else {
        self.changeImage(self.currentImageIndex + 1);
      }
      return false;
    });

    /*
      Show context menu for image on right-click

      There is a div containing the navigation that spans the entire image and lives above of it. If
      you right-click, you are right clicking this div and not the image. This prevents users from
      saving the image or using other context menu actions with the image.

      To fix this, when we detect the right mouse button is pressed down, but not yet clicked, we
      set pointer-events to none on the nav div. This is so that the upcoming right-click event on
      the next mouseup will bubble down to the image. Once the right-click/contextmenu event occurs
      we set the pointer events back to auto for the nav div so it can capture hover and left-click
      events as usual.
     */
    this.$nav.on('mousedown', function(event) {
      if (event.which === 3) {
        self.$nav.css('pointer-events', 'none');

        self.$lightbox.one('contextmenu', function() {
          setTimeout(function() {
              this.$nav.css('pointer-events', 'auto');
          }.bind(self), 0);
        });
      }
    });


    this.$lightbox.find('.lb-loader, .lb-close').on('click', function() {
      self.end();
      return false;
    });
  };

  // Show overlay and lightbox. If the image is part of a set, add siblings to album array.
  Lightbox.prototype.start = function($link) {
    var self    = this;
    var $window = $(window);

    $window.on('resize', $.proxy(this.sizeOverlay, this));

    $('select, object, embed').css({
      visibility: 'hidden'
    });

    this.sizeOverlay();

    this.album = [];
    var imageNumber = 0;

    function addToAlbum($link) {
      self.album.push({
        link: $link.attr('href'),
        title: $link.attr('data-title') || $link.attr('title')
      });
    }

    // Support both data-lightbox attribute and rel attribute implementations
    var dataLightboxValue = $link.attr('data-lightbox');
    var $links;

    if (dataLightboxValue) {
      $links = $($link.prop('tagName') + '[data-lightbox="' + dataLightboxValue + '"]');
      for (var i = 0; i < $links.length; i = ++i) {
        addToAlbum($($links[i]));
        if ($links[i] === $link[0]) {
          imageNumber = i;
        }
      }
    } else {
      if ($link.attr('rel') === 'lightbox') {
        // If image is not part of a set
        addToAlbum($link);
      } else {
        // If image is part of a set
        $links = $($link.prop('tagName') + '[rel="' + $link.attr('rel') + '"]');
        for (var j = 0; j < $links.length; j = ++j) {
          addToAlbum($($links[j]));
          if ($links[j] === $link[0]) {
            imageNumber = j;
          }
        }
      }
    }

    // Position Lightbox
    var top  = $window.scrollTop() + this.options.positionFromTop;
    var left = $window.scrollLeft();
    this.$lightbox.css({
      top: top + 'px',
      left: left + 'px'
    }).fadeIn(this.options.fadeDuration);

    // Disable scrolling of the page while open
    if (this.options.disableScrolling) {
      $('body').addClass('lb-disable-scrolling');
    }

    this.changeImage(imageNumber);
  };

  // Hide most UI elements in preparation for the animated resizing of the lightbox.
  Lightbox.prototype.changeImage = function(imageNumber) {
    var self = this;

    this.disableKeyboardNav();
    var $image = this.$lightbox.find('.lb-image');

    this.$overlay.fadeIn(this.options.fadeDuration);

    $('.lb-loader').fadeIn('slow');
    this.$lightbox.find('.lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption').hide();

    this.$outerContainer.addClass('animating');

    // When image to show is preloaded, we send the width and height to sizeContainer()
    var preloader = new Image();
    preloader.onload = function() {
      var $preloader;
      var imageHeight;
      var imageWidth;
      var maxImageHeight;
      var maxImageWidth;
      var windowHeight;
      var windowWidth;

      $image.attr('src', self.album[imageNumber].link);

      $preloader = $(preloader);

      $image.width(preloader.width);
      $image.height(preloader.height);

      if (self.options.fitImagesInViewport) {
        // Fit image inside the viewport.
        // Take into account the border around the image and an additional 10px gutter on each side.

        windowWidth    = $(window).width();
        windowHeight   = $(window).height();
        maxImageWidth  = windowWidth - self.containerPadding.left - self.containerPadding.right - self.imageBorderWidth.left - self.imageBorderWidth.right - 20;
        maxImageHeight = windowHeight - self.containerPadding.top - self.containerPadding.bottom - self.imageBorderWidth.top - self.imageBorderWidth.bottom - 120;

        // Check if image size is larger then maxWidth|maxHeight in settings
        if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
          maxImageWidth = self.options.maxWidth;
        }
        if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
          maxImageHeight = self.options.maxHeight;
        }

        // Is the current image's width or height is greater than the maxImageWidth or maxImageHeight
        // option than we need to size down while maintaining the aspect ratio.
        if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
          if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
            imageWidth  = maxImageWidth;
            imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
            $image.width(imageWidth);
            $image.height(imageHeight);
          } else {
            imageHeight = maxImageHeight;
            imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
            $image.width(imageWidth);
            $image.height(imageHeight);
          }
        }
      }
      self.sizeContainer($image.width(), $image.height());
    };

    preloader.src          = this.album[imageNumber].link;
    this.currentImageIndex = imageNumber;
  };

  // Stretch overlay to fit the viewport
  Lightbox.prototype.sizeOverlay = function() {
    this.$overlay
      .width($(document).width())
      .height($(document).height());
  };

  // Animate the size of the lightbox to fit the image we are showing
  Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
    var self = this;

    var oldWidth  = this.$outerContainer.outerWidth();
    var oldHeight = this.$outerContainer.outerHeight();
    var newWidth  = imageWidth + this.containerPadding.left + this.containerPadding.right + this.imageBorderWidth.left + this.imageBorderWidth.right;
    var newHeight = imageHeight + this.containerPadding.top + this.containerPadding.bottom + this.imageBorderWidth.top + this.imageBorderWidth.bottom;

    function postResize() {
      self.$lightbox.find('.lb-dataContainer').width(newWidth);
      self.$lightbox.find('.lb-prevLink').height(newHeight);
      self.$lightbox.find('.lb-nextLink').height(newHeight);
      self.showImage();
    }

    if (oldWidth !== newWidth || oldHeight !== newHeight) {
      this.$outerContainer.animate({
        width: newWidth,
        height: newHeight
      }, this.options.resizeDuration, 'swing', function() {
        postResize();
      });
    } else {
      postResize();
    }
  };

  // Display the image and its details and begin preload neighboring images.
  Lightbox.prototype.showImage = function() {
    this.$lightbox.find('.lb-loader').stop(true).hide();
    this.$lightbox.find('.lb-image').fadeIn(this.options.imageFadeDuration);

    this.updateNav();
    this.updateDetails();
    this.preloadNeighboringImages();
    this.enableKeyboardNav();
  };

  // Display previous and next navigation if appropriate.
  Lightbox.prototype.updateNav = function() {
    // Check to see if the browser supports touch events. If so, we take the conservative approach
    // and assume that mouse hover events are not supported and always show prev/next navigation
    // arrows in image sets.
    var alwaysShowNav = false;
    try {
      document.createEvent('TouchEvent');
      alwaysShowNav = (this.options.alwaysShowNavOnTouchDevices) ? true : false;
    } catch (e) {}

    this.$lightbox.find('.lb-nav').show();

    if (this.album.length > 1) {
      if (this.options.wrapAround) {
        if (alwaysShowNav) {
          this.$lightbox.find('.lb-prev, .lb-next').css('opacity', '1');
        }
        this.$lightbox.find('.lb-prev, .lb-next').show();
      } else {
        if (this.currentImageIndex > 0) {
          this.$lightbox.find('.lb-prev').show();
          if (alwaysShowNav) {
            this.$lightbox.find('.lb-prev').css('opacity', '1');
          }
        }
        if (this.currentImageIndex < this.album.length - 1) {
          this.$lightbox.find('.lb-next').show();
          if (alwaysShowNav) {
            this.$lightbox.find('.lb-next').css('opacity', '1');
          }
        }
      }
    }
  };

  // Display caption, image number, and closing button.
  Lightbox.prototype.updateDetails = function() {
    var self = this;

    // Enable anchor clicks in the injected caption html.
    // Thanks Nate Wright for the fix. @https://github.com/NateWr
    if (typeof this.album[this.currentImageIndex].title !== 'undefined' &&
      this.album[this.currentImageIndex].title !== '') {
      var $caption = this.$lightbox.find('.lb-caption');
      if (this.options.sanitizeTitle) {
        $caption.text(this.album[this.currentImageIndex].title);
      } else {
        $caption.html(this.album[this.currentImageIndex].title);
      }
      $caption.fadeIn('fast')
        .find('a').on('click', function(event) {
          if ($(this).attr('target') !== undefined) {
            window.open($(this).attr('href'), $(this).attr('target'));
          } else {
            location.href = $(this).attr('href');
          }
        });
    }

    if (this.album.length > 1 && this.options.showImageNumberLabel) {
      var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
      this.$lightbox.find('.lb-number').text(labelText).fadeIn('fast');
    } else {
      this.$lightbox.find('.lb-number').hide();
    }

    this.$outerContainer.removeClass('animating');

    this.$lightbox.find('.lb-dataContainer').fadeIn(this.options.resizeDuration, function() {
      return self.sizeOverlay();
    });
  };

  // Preload previous and next images in set.
  Lightbox.prototype.preloadNeighboringImages = function() {
    if (this.album.length > this.currentImageIndex + 1) {
      var preloadNext = new Image();
      preloadNext.src = this.album[this.currentImageIndex + 1].link;
    }
    if (this.currentImageIndex > 0) {
      var preloadPrev = new Image();
      preloadPrev.src = this.album[this.currentImageIndex - 1].link;
    }
  };

  Lightbox.prototype.enableKeyboardNav = function() {
    $(document).on('keyup.keyboard', $.proxy(this.keyboardAction, this));
  };

  Lightbox.prototype.disableKeyboardNav = function() {
    $(document).off('.keyboard');
  };

  Lightbox.prototype.keyboardAction = function(event) {
    var KEYCODE_ESC        = 27;
    var KEYCODE_LEFTARROW  = 37;
    var KEYCODE_RIGHTARROW = 39;

    var keycode = event.keyCode;
    var key     = String.fromCharCode(keycode).toLowerCase();
    if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
      this.end();
    } else if (key === 'p' || keycode === KEYCODE_LEFTARROW) {
      if (this.currentImageIndex !== 0) {
        this.changeImage(this.currentImageIndex - 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(this.album.length - 1);
      }
    } else if (key === 'n' || keycode === KEYCODE_RIGHTARROW) {
      if (this.currentImageIndex !== this.album.length - 1) {
        this.changeImage(this.currentImageIndex + 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(0);
      }
    }
  };

  // Closing time. :-(
  Lightbox.prototype.end = function() {
    this.disableKeyboardNav();
    $(window).off('resize', this.sizeOverlay);
    this.$lightbox.fadeOut(this.options.fadeDuration);
    this.$overlay.fadeOut(this.options.fadeDuration);
    $('select, object, embed').css({
      visibility: 'visible'
    });
    if (this.options.disableScrolling) {
      $('body').removeClass('lb-disable-scrolling');
    }
  };

  return new Lightbox();
}));

/*! lightslider - v1.1.6 - 2016-10-25
* https://github.com/sachinchoolur/lightslider
* Copyright (c) 2016 Sachin N; Licensed MIT */
(function ($, undefined) {
    'use strict';
    var defaults = {
        item: 5,
        autoWidth: false,
        slideMove: 1,
        slideMargin: 10,
        addClass: '',
        mode: 'slide',
        useCSS: true,
        cssEasing: 'ease', //'cubic-bezier(0.25, 0, 0.25, 1)',
        easing: 'linear', //'for jquery animation',//
        speed: 400, //ms'
        auto: false,
        pauseOnHover: false,
        loop: false,
        slideEndAnimation: true,
        pause: 2000,
        keyPress: false,
        controls: true,
        prevHtml: '',
        nextHtml: '',
        rtl: false,
        adaptiveHeight: false,
        vertical: false,
        verticalHeight: 500,
        vThumbWidth: 100,
        thumbItem: 10,
        pager: true,
        gallery: false,
        galleryMargin: 5,
        thumbMargin: 5,
        currentPagerPosition: 'middle',
        enableTouch: true,
        enableDrag: true,
        freeMove: true,
        swipeThreshold: 40,
        responsive: [],
        /* jshint ignore:start */
        onBeforeStart: function ($el) {},
        onSliderLoad: function ($el) {},
        onBeforeSlide: function ($el, scene) {},
        onAfterSlide: function ($el, scene) {},
        onBeforeNextSlide: function ($el, scene) {},
        onBeforePrevSlide: function ($el, scene) {}
        /* jshint ignore:end */
    };
    $.fn.lightSlider = function (options) {
        if (this.length === 0) {
            return this;
        }

        if (this.length > 1) {
            this.each(function () {
                $(this).lightSlider(options);
            });
            return this;
        }

        var plugin = {},
            settings = $.extend(true, {}, defaults, options),
            settingsTemp = {},
            $el = this;
        plugin.$el = this;

        if (settings.mode === 'fade') {
            settings.vertical = false;
        }
        var $children = $el.children(),
            windowW = $(window).width(),
            breakpoint = null,
            resposiveObj = null,
            length = 0,
            w = 0,
            on = false,
            elSize = 0,
            $slide = '',
            scene = 0,
            property = (settings.vertical === true) ? 'height' : 'width',
            gutter = (settings.vertical === true) ? 'margin-bottom' : 'margin-right',
            slideValue = 0,
            pagerWidth = 0,
            slideWidth = 0,
            thumbWidth = 0,
            interval = null,
            isTouch = ('ontouchstart' in document.documentElement);
        var refresh = {};

        refresh.chbreakpoint = function () {
            windowW = $(window).width();
            if (settings.responsive.length) {
                var item;
                if (settings.autoWidth === false) {
                    item = settings.item;
                }
                if (windowW < settings.responsive[0].breakpoint) {
                    for (var i = 0; i < settings.responsive.length; i++) {
                        if (windowW < settings.responsive[i].breakpoint) {
                            breakpoint = settings.responsive[i].breakpoint;
                            resposiveObj = settings.responsive[i];
                        }
                    }
                }
                if (typeof resposiveObj !== 'undefined' && resposiveObj !== null) {
                    for (var j in resposiveObj.settings) {
                        if (resposiveObj.settings.hasOwnProperty(j)) {
                            if (typeof settingsTemp[j] === 'undefined' || settingsTemp[j] === null) {
                                settingsTemp[j] = settings[j];
                            }
                            settings[j] = resposiveObj.settings[j];
                        }
                    }
                }
                if (!$.isEmptyObject(settingsTemp) && windowW > settings.responsive[0].breakpoint) {
                    for (var k in settingsTemp) {
                        if (settingsTemp.hasOwnProperty(k)) {
                            settings[k] = settingsTemp[k];
                        }
                    }
                }
                if (settings.autoWidth === false) {
                    if (slideValue > 0 && slideWidth > 0) {
                        if (item !== settings.item) {
                            scene = Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove));
                        }
                    }
                }
            }
        };

        refresh.calSW = function () {
            if (settings.autoWidth === false) {
                slideWidth = (elSize - ((settings.item * (settings.slideMargin)) - settings.slideMargin)) / settings.item;
            }
        };

        refresh.calWidth = function (cln) {
            var ln = cln === true ? $slide.find('.lslide').length : $children.length;
            if (settings.autoWidth === false) {
                w = ln * (slideWidth + settings.slideMargin);
            } else {
                w = 0;
                for (var i = 0; i < ln; i++) {
                    w += (parseInt($children.eq(i).width()) + settings.slideMargin);
                }
            }
            return w;
        };
        plugin = {
            doCss: function () {
                var support = function () {
                    var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
                    var root = document.documentElement;
                    for (var i = 0; i < transition.length; i++) {
                        if (transition[i] in root.style) {
                            return true;
                        }
                    }
                };
                if (settings.useCSS && support()) {
                    return true;
                }
                return false;
            },
            keyPress: function () {
                if (settings.keyPress) {
                    $(document).on('keyup.lightslider', function (e) {
                        if (!$(':focus').is('input, textarea')) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            } else {
                                e.returnValue = false;
                            }
                            if (e.keyCode === 37) {
                                $el.goToPrevSlide();
                            } else if (e.keyCode === 39) {
                                $el.goToNextSlide();
                            }
                        }
                    });
                }
            },
            controls: function () {
                if (settings.controls) {
                    $el.after('<div class="lSAction"><a class="lSPrev">' + settings.prevHtml + '</a><a class="lSNext">' + settings.nextHtml + '</a></div>');
                    if (!settings.autoWidth) {
                        if (length <= settings.item) {
                            $slide.find('.lSAction').hide();
                        }
                    } else {
                        if (refresh.calWidth(false) < elSize) {
                            $slide.find('.lSAction').hide();
                        }
                    }
                    $slide.find('.lSAction a').on('click', function (e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        } else {
                            e.returnValue = false;
                        }
                        if ($(this).attr('class') === 'lSPrev') {
                            $el.goToPrevSlide();
                        } else {
                            $el.goToNextSlide();
                        }
                        return false;
                    });
                }
            },
            initialStyle: function () {
                var $this = this;
                if (settings.mode === 'fade') {
                    settings.autoWidth = false;
                    settings.slideEndAnimation = false;
                }
                if (settings.auto) {
                    settings.slideEndAnimation = false;
                }
                if (settings.autoWidth) {
                    settings.slideMove = 1;
                    settings.item = 1;
                }
                if (settings.loop) {
                    settings.slideMove = 1;
                    settings.freeMove = false;
                }
                settings.onBeforeStart.call(this, $el);
                refresh.chbreakpoint();
                $el.addClass('lightSlider').wrap('<div class="lSSlideOuter ' + settings.addClass + '"><div class="lSSlideWrapper"></div></div>');
                $slide = $el.parent('.lSSlideWrapper');
                if (settings.rtl === true) {
                    $slide.parent().addClass('lSrtl');
                }
                if (settings.vertical) {
                    $slide.parent().addClass('vertical');
                    elSize = settings.verticalHeight;
                    $slide.css('height', elSize + 'px');
                } else {
                    elSize = $el.outerWidth();
                }
                $children.addClass('lslide');
                if (settings.loop === true && settings.mode === 'slide') {
                    refresh.calSW();
                    refresh.clone = function () {
                        if (refresh.calWidth(true) > elSize) {
                            /**/
                            var tWr = 0,
                                tI = 0;
                            for (var k = 0; k < $children.length; k++) {
                                tWr += (parseInt($el.find('.lslide').eq(k).width()) + settings.slideMargin);
                                tI++;
                                if (tWr >= (elSize + settings.slideMargin)) {
                                    break;
                                }
                            }
                            var tItem = settings.autoWidth === true ? tI : settings.item;

                            /**/
                            if (tItem < $el.find('.clone.left').length) {
                                for (var i = 0; i < $el.find('.clone.left').length - tItem; i++) {
                                    $children.eq(i).remove();
                                }
                            }
                            if (tItem < $el.find('.clone.right').length) {
                                for (var j = $children.length - 1; j > ($children.length - 1 - $el.find('.clone.right').length); j--) {
                                    scene--;
                                    $children.eq(j).remove();
                                }
                            }
                            /**/
                            for (var n = $el.find('.clone.right').length; n < tItem; n++) {
                                $el.find('.lslide').eq(n).clone().removeClass('lslide').addClass('clone right').appendTo($el);
                                scene++;
                            }
                            for (var m = $el.find('.lslide').length - $el.find('.clone.left').length; m > ($el.find('.lslide').length - tItem); m--) {
                                $el.find('.lslide').eq(m - 1).clone().removeClass('lslide').addClass('clone left').prependTo($el);
                            }
                            $children = $el.children();
                        } else {
                            if ($children.hasClass('clone')) {
                                $el.find('.clone').remove();
                                $this.move($el, 0);
                            }
                        }
                    };
                    refresh.clone();
                }
                refresh.sSW = function () {
                    length = $children.length;
                    if (settings.rtl === true && settings.vertical === false) {
                        gutter = 'margin-left';
                    }
                    if (settings.autoWidth === false) {
                        $children.css(property, slideWidth + 'px');
                    }
                    $children.css(gutter, settings.slideMargin + 'px');
                    w = refresh.calWidth(false);
                    $el.css(property, w + 'px');
                    if (settings.loop === true && settings.mode === 'slide') {
                        if (on === false) {
                            scene = $el.find('.clone.left').length;
                        }
                    }
                };
                refresh.calL = function () {
                    $children = $el.children();
                    length = $children.length;
                };
                if (this.doCss()) {
                    $slide.addClass('usingCss');
                }
                refresh.calL();
                if (settings.mode === 'slide') {
                    refresh.calSW();
                    refresh.sSW();
                    if (settings.loop === true) {
                        slideValue = $this.slideValue();
                        this.move($el, slideValue);
                    }
                    if (settings.vertical === false) {
                        this.setHeight($el, false);
                    }

                } else {
                    this.setHeight($el, true);
                    $el.addClass('lSFade');
                    if (!this.doCss()) {
                        $children.fadeOut(0);
                        $children.eq(scene).fadeIn(0);
                    }
                }
                if (settings.loop === true && settings.mode === 'slide') {
                    $children.eq(scene).addClass('active');
                } else {
                    $children.first().addClass('active');
                }
            },
            pager: function () {
                var $this = this;
                refresh.createPager = function () {
                    thumbWidth = (elSize - ((settings.thumbItem * (settings.thumbMargin)) - settings.thumbMargin)) / settings.thumbItem;
                    var $children = $slide.find('.lslide');
                    var length = $slide.find('.lslide').length;
                    var i = 0,
                        pagers = '',
                        v = 0;
                    for (i = 0; i < length; i++) {
                        if (settings.mode === 'slide') {
                            // calculate scene * slide value
                            if (!settings.autoWidth) {
                                v = i * ((slideWidth + settings.slideMargin) * settings.slideMove);
                            } else {
                                v += ((parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove);
                            }
                        }
                        var thumb = $children.eq(i * settings.slideMove).attr('data-thumb');
                        if (settings.gallery === true) {
                            pagers += '<li style="width:100%;' + property + ':' + thumbWidth + 'px;' + gutter + ':' + settings.thumbMargin + 'px"><a href="#"><img src="' + thumb + '" /></a></li>';
                        } else {
                            pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
                        }
                        if (settings.mode === 'slide') {
                            if ((v) >= w - elSize - settings.slideMargin) {
                                i = i + 1;
                                var minPgr = 2;
                                if (settings.autoWidth) {
                                    pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
                                    minPgr = 1;
                                }
                                if (i < minPgr) {
                                    pagers = null;
                                    $slide.parent().addClass('noPager');
                                } else {
                                    $slide.parent().removeClass('noPager');
                                }
                                break;
                            }
                        }
                    }
                    var $cSouter = $slide.parent();
                    $cSouter.find('.lSPager').html(pagers); 
                    if (settings.gallery === true) {
                        if (settings.vertical === true) {
                            // set Gallery thumbnail width
                            $cSouter.find('.lSPager').css('width', settings.vThumbWidth + 'px');
                        }
                        pagerWidth = (i * (settings.thumbMargin + thumbWidth)) + 0.5;
                        $cSouter.find('.lSPager').css({
                            property: pagerWidth + 'px',
                            'transition-duration': settings.speed + 'ms'
                        });
                        if (settings.vertical === true) {
                            $slide.parent().css('padding-right', (settings.vThumbWidth + settings.galleryMargin) + 'px');
                        }
                        $cSouter.find('.lSPager').css(property, pagerWidth + 'px');
                    }
                    var $pager = $cSouter.find('.lSPager').find('li');
                    $pager.first().addClass('active');
                    $pager.on('click', function () {
                        if (settings.loop === true && settings.mode === 'slide') {
                            scene = scene + ($pager.index(this) - $cSouter.find('.lSPager').find('li.active').index());
                        } else {
                            scene = $pager.index(this);
                        }
                        $el.mode(false);
                        if (settings.gallery === true) {
                            $this.slideThumb();
                        }
                        return false;
                    });
                };
                if (settings.pager) {
                    var cl = 'lSpg';
                    if (settings.gallery) {
                        cl = 'lSGallery';
                    }
                    $slide.after('<ul class="lSPager ' + cl + '"></ul>');
                    var gMargin = (settings.vertical) ? 'margin-left' : 'margin-top';
                    $slide.parent().find('.lSPager').css(gMargin, settings.galleryMargin + 'px');
                    refresh.createPager();
                }

                setTimeout(function () {
                    refresh.init();
                }, 0);
            },
            setHeight: function (ob, fade) {
                var obj = null,
                    $this = this;
                if (settings.loop) {
                    obj = ob.children('.lslide ').first();
                } else {
                    obj = ob.children().first();
                }
                var setCss = function () {
                    var tH = obj.outerHeight(),
                        tP = 0,
                        tHT = tH;
                    if (fade) {
                        tH = 0;
                        tP = ((tHT) * 100) / elSize;
                    }
                    ob.css({
                        'height': tH + 'px',
                        'padding-bottom': tP + '%'
                    });
                };
                setCss();
                if (obj.find('img').length) {
                    if ( obj.find('img')[0].complete) {
                        setCss();
                        if (!interval) {
                            $this.auto();
                        }   
                    }else{
                        obj.find('img').on('load', function () {
                            setTimeout(function () {
                                setCss();
                                if (!interval) {
                                    $this.auto();
                                }
                            }, 100);
                        });
                    }
                }else{
                    if (!interval) {
                        $this.auto();
                    }
                }
            },
            active: function (ob, t) {
                if (this.doCss() && settings.mode === 'fade') {
                    $slide.addClass('on');
                }
                var sc = 0;
                if (scene * settings.slideMove < length) {
                    ob.removeClass('active');
                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
                        ob.fadeOut(settings.speed);
                    }
                    if (t === true) {
                        sc = scene;
                    } else {
                        sc = scene * settings.slideMove;
                    }
                    //t === true ? sc = scene : sc = scene * settings.slideMove;
                    var l, nl;
                    if (t === true) {
                        l = ob.length;
                        nl = l - 1;
                        if (sc + 1 >= l) {
                            sc = nl;
                        }
                    }
                    if (settings.loop === true && settings.mode === 'slide') {
                        //t === true ? sc = scene - $el.find('.clone.left').length : sc = scene * settings.slideMove;
                        if (t === true) {
                            sc = scene - $el.find('.clone.left').length;
                        } else {
                            sc = scene * settings.slideMove;
                        }
                        if (t === true) {
                            l = ob.length;
                            nl = l - 1;
                            if (sc + 1 === l) {
                                sc = nl;
                            } else if (sc + 1 > l) {
                                sc = 0;
                            }
                        }
                    }

                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
                        ob.eq(sc).fadeIn(settings.speed);
                    }
                    ob.eq(sc).addClass('active');
                } else {
                    ob.removeClass('active');
                    ob.eq(ob.length - 1).addClass('active');
                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
                        ob.fadeOut(settings.speed);
                        ob.eq(sc).fadeIn(settings.speed);
                    }
                }
            },
            move: function (ob, v) {
                if (settings.rtl === true) {
                    v = -v;
                }
                if (this.doCss()) {
                    if (settings.vertical === true) {
                        ob.css({
                            'transform': 'translate3d(0px, ' + (-v) + 'px, 0px)',
                            '-webkit-transform': 'translate3d(0px, ' + (-v) + 'px, 0px)'
                        });
                    } else {
                        ob.css({
                            'transform': 'translate3d(' + (-v) + 'px, 0px, 0px)',
                            '-webkit-transform': 'translate3d(' + (-v) + 'px, 0px, 0px)',
                        });
                    }
                } else {
                    if (settings.vertical === true) {
                        ob.css('position', 'relative').animate({
                            top: -v + 'px'
                        }, settings.speed, settings.easing);
                    } else {
                        ob.css('position', 'relative').animate({
                            left: -v + 'px'
                        }, settings.speed, settings.easing);
                    }
                }
                var $thumb = $slide.parent().find('.lSPager').find('li');
                this.active($thumb, true);
            },
            fade: function () {
                this.active($children, false);
                var $thumb = $slide.parent().find('.lSPager').find('li');
                this.active($thumb, true);
            },
            slide: function () {
                var $this = this;
                refresh.calSlide = function () {
                    if (w > elSize) {
                        slideValue = $this.slideValue();
                        $this.active($children, false);
                        if ((slideValue) > w - elSize - settings.slideMargin) {
                            slideValue = w - elSize - settings.slideMargin;
                        } else if (slideValue < 0) {
                            slideValue = 0;
                        }
                        $this.move($el, slideValue);
                        if (settings.loop === true && settings.mode === 'slide') {
                            if (scene >= (length - ($el.find('.clone.left').length / settings.slideMove))) {
                                $this.resetSlide($el.find('.clone.left').length);
                            }
                            if (scene === 0) {
                                $this.resetSlide($slide.find('.lslide').length);
                            }
                        }
                    }
                };
                refresh.calSlide();
            },
            resetSlide: function (s) {
                var $this = this;
                $slide.find('.lSAction a').addClass('disabled');
                setTimeout(function () {
                    scene = s;
                    $slide.css('transition-duration', '0ms');
                    slideValue = $this.slideValue();
                    $this.active($children, false);
                    plugin.move($el, slideValue);
                    setTimeout(function () {
                        $slide.css('transition-duration', settings.speed + 'ms');
                        $slide.find('.lSAction a').removeClass('disabled');
                    }, 50);
                }, settings.speed + 100);
            },
            slideValue: function () {
                var _sV = 0;
                if (settings.autoWidth === false) {
                    _sV = scene * ((slideWidth + settings.slideMargin) * settings.slideMove);
                } else {
                    _sV = 0;
                    for (var i = 0; i < scene; i++) {
                        _sV += (parseInt($children.eq(i).width()) + settings.slideMargin);
                    }
                }
                return _sV;
            },
            slideThumb: function () {
                var position;
                switch (settings.currentPagerPosition) {
                case 'left':
                    position = 0;
                    break;
                case 'middle':
                    position = (elSize / 2) - (thumbWidth / 2);
                    break;
                case 'right':
                    position = elSize - thumbWidth;
                }
                var sc = scene - $el.find('.clone.left').length;
                var $pager = $slide.parent().find('.lSPager');
                if (settings.mode === 'slide' && settings.loop === true) {
                    if (sc >= $pager.children().length) {
                        sc = 0;
                    } else if (sc < 0) {
                        sc = $pager.children().length;
                    }
                }
                var thumbSlide = sc * ((thumbWidth + settings.thumbMargin)) - (position);
                if ((thumbSlide + elSize) > pagerWidth) {
                    thumbSlide = pagerWidth - elSize - settings.thumbMargin;
                }
                if (thumbSlide < 0) {
                    thumbSlide = 0;
                }
                this.move($pager, thumbSlide);
            },
            auto: function () {
                if (settings.auto) {
                    clearInterval(interval);
                    interval = setInterval(function () {
                        $el.goToNextSlide();
                    }, settings.pause);
                }
            },
            pauseOnHover: function(){
                var $this = this;
                if (settings.auto && settings.pauseOnHover) {
                    $slide.on('mouseenter', function(){
                        $(this).addClass('ls-hover');
                        $el.pause();
                        settings.auto = true;
                    });
                    $slide.on('mouseleave',function(){
                        $(this).removeClass('ls-hover');
                        if (!$slide.find('.lightSlider').hasClass('lsGrabbing')) {
                            $this.auto();
                        }
                    });
                }
            },
            touchMove: function (endCoords, startCoords) {
                $slide.css('transition-duration', '0ms');
                if (settings.mode === 'slide') {
                    var distance = endCoords - startCoords;
                    var swipeVal = slideValue - distance;
                    if ((swipeVal) >= w - elSize - settings.slideMargin) {
                        if (settings.freeMove === false) {
                            swipeVal = w - elSize - settings.slideMargin;
                        } else {
                            var swipeValT = w - elSize - settings.slideMargin;
                            swipeVal = swipeValT + ((swipeVal - swipeValT) / 5);

                        }
                    } else if (swipeVal < 0) {
                        if (settings.freeMove === false) {
                            swipeVal = 0;
                        } else {
                            swipeVal = swipeVal / 5;
                        }
                    }
                    this.move($el, swipeVal);
                }
            },

            touchEnd: function (distance) {
                $slide.css('transition-duration', settings.speed + 'ms');
                if (settings.mode === 'slide') {
                    var mxVal = false;
                    var _next = true;
                    slideValue = slideValue - distance;
                    if ((slideValue) > w - elSize - settings.slideMargin) {
                        slideValue = w - elSize - settings.slideMargin;
                        if (settings.autoWidth === false) {
                            mxVal = true;
                        }
                    } else if (slideValue < 0) {
                        slideValue = 0;
                    }
                    var gC = function (next) {
                        var ad = 0;
                        if (!mxVal) {
                            if (next) {
                                ad = 1;
                            }
                        }
                        if (!settings.autoWidth) {
                            var num = slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove);
                            scene = parseInt(num) + ad;
                            if (slideValue >= (w - elSize - settings.slideMargin)) {
                                if (num % 1 !== 0) {
                                    scene++;
                                }
                            }
                        } else {
                            var tW = 0;
                            for (var i = 0; i < $children.length; i++) {
                                tW += (parseInt($children.eq(i).width()) + settings.slideMargin);
                                scene = i + ad;
                                if (tW >= slideValue) {
                                    break;
                                }
                            }
                        }
                    };
                    if (distance >= settings.swipeThreshold) {
                        gC(false);
                        _next = false;
                    } else if (distance <= -settings.swipeThreshold) {
                        gC(true);
                        _next = false;
                    }
                    $el.mode(_next);
                    this.slideThumb();
                } else {
                    if (distance >= settings.swipeThreshold) {
                        $el.goToPrevSlide();
                    } else if (distance <= -settings.swipeThreshold) {
                        $el.goToNextSlide();
                    }
                }
            },



            enableDrag: function () {
                var $this = this;
                if (!isTouch) {
                    var startCoords = 0,
                        endCoords = 0,
                        isDraging = false;
                    $slide.find('.lightSlider').addClass('lsGrab');
                    $slide.on('mousedown', function (e) {
                        if (w < elSize) {
                            if (w !== 0) {
                                return false;
                            }
                        }
                        if ($(e.target).attr('class') !== ('lSPrev') && $(e.target).attr('class') !== ('lSNext')) {
                            startCoords = (settings.vertical === true) ? e.pageY : e.pageX;
                            isDraging = true;
                            if (e.preventDefault) {
                                e.preventDefault();
                            } else {
                                e.returnValue = false;
                            }
                            // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                            $slide.scrollLeft += 1;
                            $slide.scrollLeft -= 1;
                            // *
                            $slide.find('.lightSlider').removeClass('lsGrab').addClass('lsGrabbing');
                            clearInterval(interval);
                        }
                    });
                    $(window).on('mousemove', function (e) {
                        if (isDraging) {
                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
                            $this.touchMove(endCoords, startCoords);
                        }
                    });
                    $(window).on('mouseup', function (e) {
                        if (isDraging) {
                            $slide.find('.lightSlider').removeClass('lsGrabbing').addClass('lsGrab');
                            isDraging = false;
                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
                            var distance = endCoords - startCoords;
                            if (Math.abs(distance) >= settings.swipeThreshold) {
                                $(window).on('click.ls', function (e) {
                                    if (e.preventDefault) {
                                        e.preventDefault();
                                    } else {
                                        e.returnValue = false;
                                    }
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                    $(window).off('click.ls');
                                });
                            }

                            $this.touchEnd(distance);

                        }
                    });
                }
            },




            enableTouch: function () {
                var $this = this;
                if (isTouch) {
                    var startCoords = {},
                        endCoords = {};
                    $slide.on('touchstart', function (e) {
                        endCoords = e.originalEvent.targetTouches[0];
                        startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
                        startCoords.pageY = e.originalEvent.targetTouches[0].pageY;
                        clearInterval(interval);
                    });
                    $slide.on('touchmove', function (e) {
                        if (w < elSize) {
                            if (w !== 0) {
                                return false;
                            }
                        }
                        var orig = e.originalEvent;
                        endCoords = orig.targetTouches[0];
                        var xMovement = Math.abs(endCoords.pageX - startCoords.pageX);
                        var yMovement = Math.abs(endCoords.pageY - startCoords.pageY);
                        if (settings.vertical === true) {
                            if ((yMovement * 3) > xMovement) {
                                e.preventDefault();
                            }
                            $this.touchMove(endCoords.pageY, startCoords.pageY);
                        } else {
                            if ((xMovement * 3) > yMovement) {
                                e.preventDefault();
                            }
                            $this.touchMove(endCoords.pageX, startCoords.pageX);
                        }

                    });
                    $slide.on('touchend', function () {
                        if (w < elSize) {
                            if (w !== 0) {
                                return false;
                            }
                        }
                        var distance;
                        if (settings.vertical === true) {
                            distance = endCoords.pageY - startCoords.pageY;
                        } else {
                            distance = endCoords.pageX - startCoords.pageX;
                        }
                        $this.touchEnd(distance);
                    });
                }
            },
            build: function () {
                var $this = this;
                $this.initialStyle();
                if (this.doCss()) {

                    if (settings.enableTouch === true) {
                        $this.enableTouch();
                    }
                    if (settings.enableDrag === true) {
                        $this.enableDrag();
                    }
                }

                $(window).on('focus', function(){
                    $this.auto();
                });
                
                $(window).on('blur', function(){
                    clearInterval(interval);
                });

                $this.pager();
                $this.pauseOnHover();
                $this.controls();
                $this.keyPress();
            }
        };
        plugin.build();
        refresh.init = function () {
            refresh.chbreakpoint();
            if (settings.vertical === true) {
                if (settings.item > 1) {
                    elSize = settings.verticalHeight;
                } else {
                    elSize = $children.outerHeight();
                }
                $slide.css('height', elSize + 'px');
            } else {
                elSize = $slide.outerWidth();
            }
            if (settings.loop === true && settings.mode === 'slide') {
                refresh.clone();
            }
            refresh.calL();
            if (settings.mode === 'slide') {
                $el.removeClass('lSSlide');
            }
            if (settings.mode === 'slide') {
                refresh.calSW();
                refresh.sSW();
            }
            setTimeout(function () {
                if (settings.mode === 'slide') {
                    $el.addClass('lSSlide');
                }
            }, 1000);
            if (settings.pager) {
                refresh.createPager();
            }
            if (settings.adaptiveHeight === true && settings.vertical === false) {
                $el.css('height', $children.eq(scene).outerHeight(true));
            }
            if (settings.adaptiveHeight === false) {
                if (settings.mode === 'slide') {
                    if (settings.vertical === false) {
                        plugin.setHeight($el, false);
                    }else{
                        plugin.auto();
                    }
                } else {
                    plugin.setHeight($el, true);
                }
            }
            if (settings.gallery === true) {
                plugin.slideThumb();
            }
            if (settings.mode === 'slide') {
                plugin.slide();
            }
            if (settings.autoWidth === false) {
                if ($children.length <= settings.item) {
                    $slide.find('.lSAction').hide();
                } else {
                    $slide.find('.lSAction').show();
                }
            } else {
                if ((refresh.calWidth(false) < elSize) && (w !== 0)) {
                    $slide.find('.lSAction').hide();
                } else {
                    $slide.find('.lSAction').show();
                }
            }
        };
        $el.goToPrevSlide = function () {
            if (scene > 0) {
                settings.onBeforePrevSlide.call(this, $el, scene);
                scene--;
                $el.mode(false);
                if (settings.gallery === true) {
                    plugin.slideThumb();
                }
            } else {
                if (settings.loop === true) {
                    settings.onBeforePrevSlide.call(this, $el, scene);
                    if (settings.mode === 'fade') {
                        var l = (length - 1);
                        scene = parseInt(l / settings.slideMove);
                    }
                    $el.mode(false);
                    if (settings.gallery === true) {
                        plugin.slideThumb();
                    }
                } else if (settings.slideEndAnimation === true) {
                    $el.addClass('leftEnd');
                    setTimeout(function () {
                        $el.removeClass('leftEnd');
                    }, 400);
                }
            }
        };
        $el.goToNextSlide = function () {
            var nextI = true;
            if (settings.mode === 'slide') {
                var _slideValue = plugin.slideValue();
                nextI = _slideValue < w - elSize - settings.slideMargin;
            }
            if (((scene * settings.slideMove) < length - settings.slideMove) && nextI) {
                settings.onBeforeNextSlide.call(this, $el, scene);
                scene++;
                $el.mode(false);
                if (settings.gallery === true) {
                    plugin.slideThumb();
                }
            } else {
                if (settings.loop === true) {
                    settings.onBeforeNextSlide.call(this, $el, scene);
                    scene = 0;
                    $el.mode(false);
                    if (settings.gallery === true) {
                        plugin.slideThumb();
                    }
                } else if (settings.slideEndAnimation === true) {
                    $el.addClass('rightEnd');
                    setTimeout(function () {
                        $el.removeClass('rightEnd');
                    }, 400);
                }
            }
        };
        $el.mode = function (_touch) {
            if (settings.adaptiveHeight === true && settings.vertical === false) {
                $el.css('height', $children.eq(scene).outerHeight(true));
            }
            if (on === false) {
                if (settings.mode === 'slide') {
                    if (plugin.doCss()) {
                        $el.addClass('lSSlide');
                        if (settings.speed !== '') {
                            $slide.css('transition-duration', settings.speed + 'ms');
                        }
                        if (settings.cssEasing !== '') {
                            $slide.css('transition-timing-function', settings.cssEasing);
                        }
                    }
                } else {
                    if (plugin.doCss()) {
                        if (settings.speed !== '') {
                            $el.css('transition-duration', settings.speed + 'ms');
                        }
                        if (settings.cssEasing !== '') {
                            $el.css('transition-timing-function', settings.cssEasing);
                        }
                    }
                }
            }
            if (!_touch) {
                settings.onBeforeSlide.call(this, $el, scene);
            }
            if (settings.mode === 'slide') {
                plugin.slide();
            } else {
                plugin.fade();
            }
            if (!$slide.hasClass('ls-hover')) {
                plugin.auto();
            }
            setTimeout(function () {
                if (!_touch) {
                    settings.onAfterSlide.call(this, $el, scene);
                }
            }, settings.speed);
            on = true;
        };
        $el.play = function () {
            $el.goToNextSlide();
            settings.auto = true;
            plugin.auto();
        };
        $el.pause = function () {
            settings.auto = false;
            clearInterval(interval);
        };
        $el.refresh = function () {
            refresh.init();
        };
        $el.getCurrentSlideCount = function () {
            var sc = scene;
            if (settings.loop) {
                var ln = $slide.find('.lslide').length,
                    cl = $el.find('.clone.left').length;
                if (scene <= cl - 1) {
                    sc = ln + (scene - cl);
                } else if (scene >= (ln + cl)) {
                    sc = scene - ln - cl;
                } else {
                    sc = scene - cl;
                }
            }
            return sc + 1;
        }; 
        $el.getTotalSlideCount = function () {
            return $slide.find('.lslide').length;
        };
        $el.goToSlide = function (s) {
            if (settings.loop) {
                scene = (s + $el.find('.clone.left').length - 1);
            } else {
                scene = s;
            }
            $el.mode(false);
            if (settings.gallery === true) {
                plugin.slideThumb();
            }
        };
        $el.destroy = function () {
            if ($el.lightSlider) {
                $el.goToPrevSlide = function(){};
                $el.goToNextSlide = function(){};
                $el.mode = function(){};
                $el.play = function(){};
                $el.pause = function(){};
                $el.refresh = function(){};
                $el.getCurrentSlideCount = function(){};
                $el.getTotalSlideCount = function(){};
                $el.goToSlide = function(){}; 
                $el.lightSlider = null;
                refresh = {
                    init : function(){}
                };
                $el.parent().parent().find('.lSAction, .lSPager').remove();
                $el.removeClass('lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right').removeAttr('style').unwrap().unwrap();
                $el.children().removeAttr('style');
                $children.removeClass('lslide active');
                $el.find('.clone').remove();
                $children = null;
                interval = null;
                on = false;
                scene = 0;
            }

        };
        setTimeout(function () {
            settings.onSliderLoad.call(this, $el);
        }, 10);
        $(window).on('resize orientationchange', function (e) {
            setTimeout(function () {
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
                refresh.init();
            }, 200);
        });
        return this;
    };
}(jQuery));

$(document).ready(function(){
    // $('#posts').jPaginate({items: 10, paginaton_class: "myownclass"});
    
    if ($(window).width() > 1199) {
        $('.parallax-container').parallax();

    }
    function setParallaxHeight(){
        var $body = $('body');
        var parallax = $('.parallax-container')[0];
        var clientHeight = $body.outerHeight();
        $(parallax).css('height', clientHeight +700+ 'px');
        console.log($(parallax).height(), clientHeight)
    }

    // $('.love').hover(function() {
    //     $(this).attr('src','https://static.parastorage.com/services/santa/1.2080.14/static/images/new-blog-social-icons/like-post-hover.svg');
    // })
    $('.love').on('click',function() {
        
        
     
        $(this).toggleClass('active');
        if(!$(this).hasClass('active')){

            $(this).attr('src', 'https://static.parastorage.com/services/santa/1.2080.14/static/images/new-blog-social-icons/like-post.svg');    
            $('.count').html(function(i, val) {
                console.log(val)
                return +val - 1
            });
        } else {
            $(this).attr('src', 'https://static.parastorage.com/services/santa/1.2080.14/static/images/new-blog-social-icons/like-post-red.svg');
            $('.count').html(function(i, val) {
                return +val + 1
            });
        }

    })

    

    $('#posts').easyPaginate({
        paginateElement: '.post-card',
        elementsPerPage: 10
    });
    $('.easyPaginateNav a').on('click',function() {
        setParallaxHeight();
    })
    if ($(window).width() < 1199) {
        var slides = $('.thumb')
        var slide;
        var newSlides = [];
        for(var i = 0; i < slides.length; i++){
            slide = $('<li>').append(slides[i]);
            newSlides.push(slide)
        }
        var $ulSlider = $('<ul class="additional-slider">').append(newSlides);
        $('.recent').append($ulSlider);
        $(".additional-slider").lightSlider({

            item: 1,
            pager: false,
            keyPress: false,
            slideMove: 1,
            slideMargin: 40,
            mode: 'slide',
            useCSS: true,
            easing: 'linear',
            loop: true,
            enableTouch: true,
            responsive: [

            ]

        });
    }

    $("#lightSlider1").lightSlider({

        item: 5,
        pager: false,
        keyPress: false,
        slideMove: 1,
        slideMargin: 40,
        mode: 'slide',
        useCSS: true,
        easing: 'linear',
        loop: true,
        enableTouch: true,
        responsive: [{
            breakpoint: 1400,
            settings: {
                item: 3,
                slideMove: 1,
                margin: 10

            }
        }, {
            breakpoint: 900,
            settings: {
                item: 2,
                slideMove: 1
            }
        }, {
            breakpoint: 540,
            settings: {
                item: 1,
                slideMove: 1,
                margin: 0
            }
        }]

    });
    $("#lightSlider2").lightSlider({

        item: 1,
        pager: false,
        keyPress: false,
        slideMove: 1,
        slideMargin: 40,
        mode: 'slide',
        useCSS: true,
        easing: 'linear',
        loop: true,
        enableTouch: true,
        responsive: [

        ]

    });
    $("#lightSliderfavorites-slider").lightSlider({

        item: 1,
        pager: false,
        keyPress: false,
        slideMove: 1,
        slideMargin: 40,
        mode: 'slide',
        useCSS: true,
        easing: 'linear',
        loop: true,
        enableTouch: true,
        responsive: [

        ]

    });

    $("#item-gallery").lightSlider({
        gallery: true,
        item: 1,
        loop: true,
        thumbItem: 9,
        slideMargin: 0,
        enableDrag: false,
        currentPagerPosition: 'left'


    });

    
   
    $(".my-foto").imagezoomsl({

     zoomrange: [3, 3]
    }).click(function(){
        console.log($(this))
    });


    var max_chars = 500;

    $('#chars-remaining').html(max_chars);

    $('#feedback').keyup(function() {
        var text_length = $(this).val().length;
        var text_remaining = max_chars - text_length;
        $('#chars-remaining').html(text_remaining);
    })



    $('.filter-accordion__title').on('click', function(e) {

        // e.preventDefault();
        e.stopPropagation();


        var $this = $(this);

        $this.toggleClass('passive');

        if ($this.next().hasClass('show')) {
            $this.next().removeClass('show').slideUp(350);

        } else {

            $this.parent().parent().find('filter-accordion__content').removeClass('show');
            $this.parent().parent().find('filter-accordion__content').slideUp(350);
            $this.next().addClass('show').slideDown(350);
        }
    });
    $('.nstSlider').nstSlider({
        "left_grip_selector": ".leftGrip",
        "right_grip_selector": ".rightGrip",
        "value_bar_selector": ".bar",
        "value_changed_callback": function(cause, leftValue, rightValue) {
            $(this).parent().find('.leftLabel').text(leftValue + ' —Ä—É–±.');
            $(this).parent().find('.rightLabel').text(rightValue + ' —Ä—É–±.');
        }
    });
    $('#current_menu').css('display', 'none')
    $("#current_page").click(function() {
        $("#current_menu").slideToggle();
    });

    $("#current_menu a").click(function(event) {
        event.preventDefault(); //prevent synchronous loading
        var text = $(this).text();
        $(this).html(text + '<span class="select-wrapper__item--checked">&#10004;</span>');
        $("#current_page").html(text + '<span class="down-arrowhead">&#709;</span>');

        $("#current_menu").slideToggle();
    });
    (function() {
        $('.post-card__info--content').text($('.post-card__info--content').text().substr(0, 300) + '...');

    })()
    setParallaxHeight();
})
/*!
 * parallax.js v1.4.2 (http://pixelcog.github.io/parallax.js/)
 * @copyright 2016 PixelCog, Inc.
 * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)
 */

;(function ( $, window, document, undefined ) {

  // Polyfill for requestAnimationFrame
  // via: https://gist.github.com/paulirish/1579671

  (function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
        || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
      window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };

    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
      };
  }());


  // Parallax Constructor

  function Parallax(element, options) {
    var self = this;

    if (typeof options == 'object') {
      delete options.refresh;
      delete options.render;
      $.extend(this, options);
    }

    this.$element = $(element);

    if (!this.imageSrc && this.$element.is('img')) {
      this.imageSrc = this.$element.attr('src');
    }

    var positions = (this.position + '').toLowerCase().match(/\S+/g) || [];

    if (positions.length < 1) {
      positions.push('center');
    }
    if (positions.length == 1) {
      positions.push(positions[0]);
    }

    if (positions[0] == 'top' || positions[0] == 'bottom' || positions[1] == 'left' || positions[1] == 'right') {
      positions = [positions[1], positions[0]];
    }

    if (this.positionX != undefined) positions[0] = this.positionX.toLowerCase();
    if (this.positionY != undefined) positions[1] = this.positionY.toLowerCase();

    self.positionX = positions[0];
    self.positionY = positions[1];

    if (this.positionX != 'left' && this.positionX != 'right') {
      if (isNaN(parseInt(this.positionX))) {
        this.positionX = 'center';
      } else {
        this.positionX = parseInt(this.positionX);
      }
    }

    if (this.positionY != 'top' && this.positionY != 'bottom') {
      if (isNaN(parseInt(this.positionY))) {
        this.positionY = 'center';
      } else {
        this.positionY = parseInt(this.positionY);
      }
    }

    this.position =
      this.positionX + (isNaN(this.positionX)? '' : 'px') + ' ' +
      this.positionY + (isNaN(this.positionY)? '' : 'px');

    if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
      if (this.imageSrc && this.iosFix && !this.$element.is('img')) {
        this.$element.css({
          backgroundImage: 'url(' + this.imageSrc + ')',
          backgroundSize: 'cover',
          backgroundPosition: this.position
        });
      }
      return this;
    }

    if (navigator.userAgent.match(/(Android)/)) {
      if (this.imageSrc && this.androidFix && !this.$element.is('img')) {
        this.$element.css({
          backgroundImage: 'url(' + this.imageSrc + ')',
          backgroundSize: 'cover',
          backgroundPosition: this.position
        });
      }
      return this;
    }

    this.$mirror = $('<div />').prependTo('body');

    var slider = this.$element.find('>.parallax-slider');
    var sliderExisted = false;

    if (slider.length == 0)
      this.$slider = $('<img />').prependTo(this.$mirror);
    else {
      this.$slider = slider.prependTo(this.$mirror)
      sliderExisted = true;
    }

    this.$mirror.addClass('parallax-mirror').css({
      visibility: 'hidden',
      zIndex: this.zIndex,
      position: 'fixed',
      top: 0,
      left: 0,
      overflow: 'hidden'
    });

    this.$slider.addClass('parallax-slider').one('load', function() {
      if (!self.naturalHeight || !self.naturalWidth) {
        self.naturalHeight = this.naturalHeight || this.height || 1;
        self.naturalWidth  = this.naturalWidth  || this.width  || 1;
      }
      self.aspectRatio = self.naturalWidth / self.naturalHeight;

      Parallax.isSetup || Parallax.setup();
      Parallax.sliders.push(self);
      Parallax.isFresh = false;
      Parallax.requestRender();
    });

    if (!sliderExisted)
      this.$slider[0].src = this.imageSrc;

    if (this.naturalHeight && this.naturalWidth || this.$slider[0].complete || slider.length > 0) {
      this.$slider.trigger('load');
    }

  };


  // Parallax Instance Methods

  $.extend(Parallax.prototype, {
    speed:    0.2,
    bleed:    0,
    zIndex:   -100,
    iosFix:   true,
    androidFix: true,
    position: 'center',
    overScrollFix: false,

    refresh: function() {
      this.boxWidth        = this.$element.outerWidth();
      this.boxHeight       = this.$element.outerHeight() + this.bleed * 2;
      this.boxOffsetTop    = this.$element.offset().top - this.bleed;
      this.boxOffsetLeft   = this.$element.offset().left;
      this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;

      var winHeight = Parallax.winHeight;
      var docHeight = Parallax.docHeight;
      var maxOffset = Math.min(this.boxOffsetTop, docHeight - winHeight);
      var minOffset = Math.max(this.boxOffsetTop + this.boxHeight - winHeight, 0);
      var imageHeightMin = this.boxHeight + (maxOffset - minOffset) * (1 - this.speed) | 0;
      var imageOffsetMin = (this.boxOffsetTop - maxOffset) * (1 - this.speed) | 0;

      if (imageHeightMin * this.aspectRatio >= this.boxWidth) {
        this.imageWidth    = imageHeightMin * this.aspectRatio | 0;
        this.imageHeight   = imageHeightMin;
        this.offsetBaseTop = imageOffsetMin;

        var margin = this.imageWidth - this.boxWidth;

        if (this.positionX == 'left') {
          this.offsetLeft = 0;
        } else if (this.positionX == 'right') {
          this.offsetLeft = - margin;
        } else if (!isNaN(this.positionX)) {
          this.offsetLeft = Math.max(this.positionX, - margin);
        } else {
          this.offsetLeft = - margin / 2 | 0;
        }
      } else {
        this.imageWidth    = this.boxWidth;
        this.imageHeight   = this.boxWidth / this.aspectRatio | 0;
        this.offsetLeft    = 0;

        var margin = this.imageHeight - imageHeightMin;

        if (this.positionY == 'top') {
          this.offsetBaseTop = imageOffsetMin;
        } else if (this.positionY == 'bottom') {
          this.offsetBaseTop = imageOffsetMin - margin;
        } else if (!isNaN(this.positionY)) {
          this.offsetBaseTop = imageOffsetMin + Math.max(this.positionY, - margin);
        } else {
          this.offsetBaseTop = imageOffsetMin - margin / 2 | 0;
        }
      }
    },

    render: function() {
      var scrollTop    = Parallax.scrollTop;
      var scrollLeft   = Parallax.scrollLeft;
      var overScroll   = this.overScrollFix ? Parallax.overScroll : 0;
      var scrollBottom = scrollTop + Parallax.winHeight;

      if (this.boxOffsetBottom > scrollTop && this.boxOffsetTop <= scrollBottom) {
        this.visibility = 'visible';
        this.mirrorTop = this.boxOffsetTop  - scrollTop;
        this.mirrorLeft = this.boxOffsetLeft - scrollLeft;
        this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
      } else {
        this.visibility = 'hidden';
      }

      this.$mirror.css({
        transform: 'translate3d(0px, 0px, 0px)',
        visibility: this.visibility,
        top: this.mirrorTop - overScroll,
        left: this.mirrorLeft,
        height: this.boxHeight,
        width: this.boxWidth
      });

      this.$slider.css({
        transform: 'translate3d(0px, 0px, 0px)',
        position: 'absolute',
        top: this.offsetTop,
        left: this.offsetLeft,
        height: this.imageHeight,
        width: this.imageWidth,
        maxWidth: 'none'
      });
    }
  });


  // Parallax Static Methods

  $.extend(Parallax, {
    scrollTop:    0,
    scrollLeft:   0,
    winHeight:    0,
    winWidth:     0,
    docHeight:    1 << 30,
    docWidth:     1 << 30,
    sliders:      [],
    isReady:      false,
    isFresh:      false,
    isBusy:       false,

    setup: function() {
      if (this.isReady) return;

      var $doc = $(document), $win = $(window);

      var loadDimensions = function() {
        Parallax.winHeight = $win.height();
        Parallax.winWidth  = $win.width();
        Parallax.docHeight = $doc.height();
        Parallax.docWidth  = $doc.width();
      };

      var loadScrollPosition = function() {
        var winScrollTop  = $win.scrollTop();
        var scrollTopMax  = Parallax.docHeight - Parallax.winHeight;
        var scrollLeftMax = Parallax.docWidth  - Parallax.winWidth;
        Parallax.scrollTop  = Math.max(0, Math.min(scrollTopMax,  winScrollTop));
        Parallax.scrollLeft = Math.max(0, Math.min(scrollLeftMax, $win.scrollLeft()));
        Parallax.overScroll = Math.max(winScrollTop - scrollTopMax, Math.min(winScrollTop, 0));
      };

      $win.on('resize.px.parallax load.px.parallax', function() {
          loadDimensions();
          Parallax.isFresh = false;
          Parallax.requestRender();
        })
        .on('scroll.px.parallax load.px.parallax', function() {
          loadScrollPosition();
          Parallax.requestRender();
        });

      loadDimensions();
      loadScrollPosition();

      this.isReady = true;
    },

    configure: function(options) {
      if (typeof options == 'object') {
        delete options.refresh;
        delete options.render;
        $.extend(this.prototype, options);
      }
    },

    refresh: function() {
      $.each(this.sliders, function(){ this.refresh() });
      this.isFresh = true;
    },

    render: function() {
      this.isFresh || this.refresh();
      $.each(this.sliders, function(){ this.render() });
    },

    requestRender: function() {
      var self = this;

      if (!this.isBusy) {
        this.isBusy = true;
        window.requestAnimationFrame(function() {
          self.render();
          self.isBusy = false;
        });
      }
    },
    destroy: function(el){
      var i,
          parallaxElement = $(el).data('px.parallax');
      parallaxElement.$mirror.remove();
      for(i=0; i < this.sliders.length; i+=1){
        if(this.sliders[i] == parallaxElement){
          this.sliders.splice(i, 1);
        }
      }
      $(el).data('px.parallax', false);
      if(this.sliders.length === 0){
        $(window).off('scroll.px.parallax resize.px.parallax load.px.parallax');
        this.isReady = false;
        Parallax.isSetup = false;
      }
    }
  });


  // Parallax Plugin Definition

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var options = typeof option == 'object' && option;

      if (this == window || this == document || $this.is('body')) {
        Parallax.configure(options);
      }
      else if (!$this.data('px.parallax')) {
        options = $.extend({}, $this.data(), options);
        $this.data('px.parallax', new Parallax(this, options));
      }
      else if (typeof option == 'object')
      {
        $.extend($this.data('px.parallax'), options);
      }
      if (typeof option == 'string') {
        if(option == 'destroy'){
            Parallax['destroy'](this);
        }else{
          Parallax[option]();
        }
      }
    })
  };

  var old = $.fn.parallax;

  $.fn.parallax             = Plugin;
  $.fn.parallax.Constructor = Parallax;


  // Parallax No Conflict

  $.fn.parallax.noConflict = function () {
    $.fn.parallax = old;
    return this;
  };


  // Parallax Data-API

  $(document).on('ready.px.parallax.data-api', function () {
    $('[data-parallax="scroll"]').parallax();
  });

}(jQuery, window, document));
/*jshint multistr:true, curly: false */
/*global jQuery:false, define: false */
/**
 * jRange - Awesome range control
 *
 * Written by
 * ----------
 * Nitin Hayaran (nitinhayaran@gmail.com)
 *
 * Licensed under the MIT (MIT-LICENSE.txt).
 *
 * @author Nitin Hayaran
 * @version 0.1-RELEASE
 *
 * Dependencies
 * ------------
 * jQuery (http://jquery.com)
 *
 **/
;
(function($, window, document, undefined) {
    'use strict';

    var jRange = function() {
        return this.init.apply(this, arguments);
    };
    jRange.prototype = {
        defaults: {
            onstatechange: function() {},
      ondragend: function() {},
      onbarclicked: function() {},
            isRange: false,
            showLabels: true,
            showScale: true,
            step: 1,
            format: '%s',
            theme: 'theme-green',
            width: 300,
            disable: false,
            snap: false
        },
        template: '<div class="slider-container">\
            <div class="back-bar">\
                <div class="selected-bar"></div>\
                <div class="pointer low"></div><div class="pointer-label low">123456</div>\
                <div class="pointer high"></div><div class="pointer-label high">456789</div>\
                <div class="clickable-dummy"></div>\
            </div>\
            <div class="scale"></div>\
        </div>',
        init: function(node, options) {
            this.options       = $.extend({}, this.defaults, options);
            this.inputNode     = $(node);
            this.options.value = this.inputNode.val() || (this.options.isRange ? this.options.from + ',' + this.options.from : '' + this.options.from);
            this.domNode       = $(this.template);
            this.domNode.addClass(this.options.theme);
            this.inputNode.after(this.domNode);
            this.domNode.on('change', this.onChange);
            this.pointers      = $('.pointer', this.domNode);
            this.lowPointer    = this.pointers.first();
            this.highPointer   = this.pointers.last();
            this.labels        = $('.pointer-label', this.domNode);
            this.lowLabel      = this.labels.first();
            this.highLabel     = this.labels.last();
            this.scale         = $('.scale', this.domNode);
            this.bar           = $('.selected-bar', this.domNode);
            this.clickableBar  = this.domNode.find('.clickable-dummy');
            this.interval      = this.options.to - this.options.from;
            this.render();
        },
        render: function() {
            // Check if inputNode is visible, and have some width, so that we can set slider width accordingly.
            if (this.inputNode.width() === 0 && !this.options.width) {
                console.log('jRange : no width found, returning');
                return;
            } else {
                this.options.width = this.options.width || this.inputNode.width();
                this.domNode.width(this.options.width);
                this.inputNode.hide();
            }

            if (this.isSingle()) {
                this.lowPointer.hide();
                this.lowLabel.hide();
            }
            if (!this.options.showLabels) {
                this.labels.hide();
            }
            this.attachEvents();
            if (this.options.showScale) {
                this.renderScale();
            }
            this.setValue(this.options.value);
        },
        isSingle: function() {
            if (typeof(this.options.value) === 'number') {
                return true;
            }
            return (this.options.value.indexOf(',') !== -1 || this.options.isRange) ?
                false : true;
        },
        attachEvents: function() {
            this.clickableBar.click($.proxy(this.barClicked, this));
            this.pointers.on('mousedown touchstart', $.proxy(this.onDragStart, this));
            this.pointers.bind('dragstart', function(event) {
                event.preventDefault();
            });
        },
        onDragStart: function(e) {
            if ( this.options.disable || (e.type === 'mousedown' && e.which !== 1)) {
                return;
            }
            e.stopPropagation();
            e.preventDefault();
            var pointer = $(e.target);
            this.pointers.removeClass('last-active');
            pointer.addClass('focused last-active');
            this[(pointer.hasClass('low') ? 'low' : 'high') + 'Label'].addClass('focused');
            $(document).on('mousemove.slider touchmove.slider', $.proxy(this.onDrag, this, pointer));
            $(document).on('mouseup.slider touchend.slider touchcancel.slider', $.proxy(this.onDragEnd, this));
        },
        onDrag: function(pointer, e) {
            e.stopPropagation();
            e.preventDefault();

            if (e.originalEvent.touches && e.originalEvent.touches.length) {
                e = e.originalEvent.touches[0];
            } else if (e.originalEvent.changedTouches && e.originalEvent.changedTouches.length) {
                e = e.originalEvent.changedTouches[0];
            }

            var position = e.clientX - this.domNode.offset().left;
            this.domNode.trigger('change', [this, pointer, position]);
        },
        onDragEnd: function(e) {
            this.pointers.removeClass('focused')
                .trigger('rangeslideend');
            this.labels.removeClass('focused');
            $(document).off('.slider');
          this.options.ondragend.call(this, this.options.value);
        },
        barClicked: function(e) {
            if(this.options.disable) return;
            var x = e.pageX - this.clickableBar.offset().left;
            if (this.isSingle())
                this.setPosition(this.pointers.last(), x, true, true);
            else {
                var firstLeft       = Math.abs(parseFloat(this.pointers.first().css('left'), 10)),
                        firstHalfWidth  = this.pointers.first().width() / 2,
                        lastLeft                = Math.abs(parseFloat(this.pointers.last().css('left'), 10)),
                        lastHalfWidth   = this.pointers.first().width() / 2,
                        leftSide        = Math.abs(firstLeft - x + firstHalfWidth),
                        rightSide       = Math.abs(lastLeft - x + lastHalfWidth),
                        pointer;

                if(leftSide == rightSide) {
                    pointer = x < firstLeft ? this.pointers.first() : this.pointers.last();
                } else {
                    pointer = leftSide < rightSide ? this.pointers.first() : this.pointers.last();
                }
                this.setPosition(pointer, x, true, true);
            }
            this.options.onbarclicked.call(this, this.options.value);
        },
        onChange: function(e, self, pointer, position) {
            var min, max;
            min = 0;
            max = self.domNode.width();

            if (!self.isSingle()) {
                min = pointer.hasClass('high') ? parseFloat(self.lowPointer.css("left")) + (self.lowPointer.width() / 2) : 0;
                max = pointer.hasClass('low') ? parseFloat(self.highPointer.css("left")) + (self.highPointer.width() / 2) : self.domNode.width();
            }

            var value = Math.min(Math.max(position, min), max);
            self.setPosition(pointer, value, true);
        },
        setPosition: function(pointer, position, isPx, animate) {
            var leftPos, rightPos,
                lowPos = parseFloat(this.lowPointer.css("left")),
                highPos = parseFloat(this.highPointer.css("left")) || 0,
                circleWidth = this.highPointer.width() / 2;
            if (!isPx) {
                position = this.prcToPx(position);
            }
            if(this.options.snap){
                var expPos = this.correctPositionForSnap(position);
                if(expPos === -1){
                    return;
                }else{
                    position = expPos;
                }
            }
            if (pointer[0] === this.highPointer[0]) {
                highPos = Math.round(position - circleWidth);
            } else {
                lowPos = Math.round(position - circleWidth);
            }
            pointer[animate ? 'animate' : 'css']({
                'left': Math.round(position - circleWidth)
            });
            if (this.isSingle()) {
                leftPos = 0;
            } else {
                leftPos = lowPos + circleWidth;
                rightPos = highPos + circleWidth;
            }
            var w = Math.round(highPos + circleWidth - leftPos);
            this.bar[animate ? 'animate' : 'css']({
                'width': Math.abs(w),
                'left': (w>0) ? leftPos : leftPos + w
            });
            this.showPointerValue(pointer, position, animate);
            this.isReadonly();
        },
        correctPositionForSnap: function(position){
            var currentValue = this.positionToValue(position) - this.options.from;
            var diff = this.options.width / (this.interval / this.options.step),
                expectedPosition = (currentValue / this.options.step) * diff;
            if( position <= expectedPosition + diff / 2 && position >= expectedPosition - diff / 2){
                return expectedPosition;
            }else{
                return -1;
            }
        },
        // will be called from outside
        setValue: function(value) {
            var values = value.toString().split(',');
            values[0] = Math.min(Math.max(values[0], this.options.from), this.options.to) + '';
            if (values.length > 1){
                values[1] = Math.min(Math.max(values[1], this.options.from), this.options.to) + '';
            }
            this.options.value = value;
            var prc = this.valuesToPrc(values.length === 2 ? values : [0, values[0]]);
            if (this.isSingle()) {
                this.setPosition(this.highPointer, prc[1]);
            } else {
                this.setPosition(this.lowPointer, prc[0]);
                this.setPosition(this.highPointer, prc[1]);
            }
        },
        renderScale: function() {
            var s = this.options.scale || [this.options.from, this.options.to];
            var prc = Math.round((100 / (s.length - 1)) * 10) / 10;
            var str = '';
            for (var i = 0; i < s.length; i++) {
                str += '<span style="left: ' + i * prc + '%">' + (s[i] != '|' ? '<ins>' + s[i] + '</ins>' : '') + '</span>';
            }
            this.scale.html(str);

            $('ins', this.scale).each(function() {
                $(this).css({
                    marginLeft: -$(this).outerWidth() / 2
                });
            });
        },
        getBarWidth: function() {
            var values = this.options.value.split(',');
            if (values.length > 1) {
                return parseFloat(values[1]) - parseFloat(values[0]);
            } else {
                return parseFloat(values[0]);
            }
        },
        showPointerValue: function(pointer, position, animate) {
            var label = $('.pointer-label', this.domNode)[pointer.hasClass('low') ? 'first' : 'last']();
            var text;
            var value = this.positionToValue(position);
            // Is it higer or lower than it should be?

            if ($.isFunction(this.options.format)) {
                var type = this.isSingle() ? undefined : (pointer.hasClass('low') ? 'low' : 'high');
                text = this.options.format(value, type);
            } else {
                text = this.options.format.replace('%s', value);
            }

            var width = label.html(text).width(),
                left = position - width / 2;
            left = Math.min(Math.max(left, 0), this.options.width - width);
            label[animate ? 'animate' : 'css']({
                left: left
            });
            this.setInputValue(pointer, value);
        },
        valuesToPrc: function(values) {
            var lowPrc = ((parseFloat(values[0]) - parseFloat(this.options.from)) * 100 / this.interval),
                highPrc = ((parseFloat(values[1]) - parseFloat(this.options.from)) * 100 / this.interval);
            return [lowPrc, highPrc];
        },
        prcToPx: function(prc) {
            return (this.domNode.width() * prc) / 100;
        },
        isDecimal: function() {
            return ((this.options.value + this.options.from + this.options.to).indexOf(".")===-1) ? false : true;
        },
        positionToValue: function(pos) {
            var value = (pos / this.domNode.width()) * this.interval;
            value = parseFloat(value, 10) + parseFloat(this.options.from, 10);
            if (this.isDecimal()) {
                var final = Math.round(Math.round(value / this.options.step) * this.options.step *100)/100;
                if (final!==0.0) {
                    final = '' + final;
                    if (final.indexOf(".")===-1) {
                        final = final + ".";
                    }
                    while (final.length - final.indexOf('.')<3) {
                        final = final + "0";
                    }
                } else {
                    final = "0.00";
                }
                return final;
            } else {
                return Math.round(value / this.options.step) * this.options.step;
            }
        },
        setInputValue: function(pointer, v) {
            // if(!isChanged) return;
            if (this.isSingle()) {
                this.options.value = v.toString();
            } else {
                var values = this.options.value.split(',');
                if (pointer.hasClass('low')) {
                    this.options.value = v + ',' + values[1];
                } else {
                    this.options.value = values[0] + ',' + v;
                }
            }
            if (this.inputNode.val() !== this.options.value) {
                this.inputNode.val(this.options.value)
                    .trigger('change');
                this.options.onstatechange.call(this, this.options.value);
            }
        },
        getValue: function() {
            return this.options.value;
        },
        getOptions: function() {
            return this.options;
        },
        getRange: function() {
            return this.options.from + "," + this.options.to;
        },
        isReadonly: function(){
            this.domNode.toggleClass('slider-readonly', this.options.disable);
        },
        disable: function(){
            this.options.disable = true;
            this.isReadonly();
        },
        enable: function(){
            this.options.disable = false;
            this.isReadonly();
        },
        toggleDisable: function(){
            this.options.disable = !this.options.disable;
            this.isReadonly();
        },
        updateRange: function(range, value) {
            var values = range.toString().split(',');
            this.interval = parseInt(values[1]) - parseInt(values[0]);
            if(value){
                this.setValue(value);
            }else{
                this.setValue(this.getValue());
            }
        }
    };

    var pluginName = 'jRange';
    // A really lightweight plugin wrapper around the constructor,
    // preventing against multiple instantiations
    $.fn[pluginName] = function(option) {
        var args = arguments,
            result;

        this.each(function() {
            var $this = $(this),
                data = $.data(this, 'plugin_' + pluginName),
                options = typeof option === 'object' && option;
            if (!data) {
                $this.data('plugin_' + pluginName, (data = new jRange(this, options)));
                $(window).resize(function() {
                    data.setValue(data.getValue());
                }); // Update slider position when window is resized to keep it in sync with scale
            }
            // if first argument is a string, call silimarly named function
            // this gives flexibility to call functions of the plugin e.g.
            //   - $('.dial').plugin('destroy');
            //   - $('.dial').plugin('render', $('.new-child'));
            if (typeof option === 'string') {
                result = data[option].apply(data, Array.prototype.slice.call(args, 1));
            }
        });

        // To enable plugin returns values
        return result || this;
    };

})(jQuery, window, document);
$(document).ready(function(e) {
    $('.subscribe-action').click(function(e) {
        var email = $('#email').val();
        var name = $('#name').val();
        if ($.trim(email).length == 0) {
        	$('.subscribe-wrapper__form--error').empty();
            $('.subscribe-wrapper__form--error').append('–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å');
            e.preventDefault();
        }
        if (validateEmail(email)) {
        	$('.subscribe-wrapper__form--error').empty();
            // $('.subscribe-wrapper__form--error').append('Email –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π');
        }
        else {
        	$('.subscribe-wrapper__form--error').empty();
            $('.subscribe-wrapper__form--error').append('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ username@domain.zone');
            e.preventDefault();
        }
        if($.trim(name).length === 0 ){
            $('.subscribe-wrapper__form--error').empty();
            $('.subscribe-wrapper__form--error').append('–í–≤–µ–¥–∏—Ç–µ –∏–º—è');
            e.preventDefault();
        }
    });
    $('.partnership-action').click(function(e) {
        var email = $('#email').val();
        var name = $('#name').val();
        if ($.trim(email).length == 0) {
            $('.partnership-wrapper__form--error').empty();
            $('.partnership-wrapper__form--error').append('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ username@domain.zone');
            e.preventDefault();
        }
        if (validateEmail(email)) {
            $('.partnership-wrapper__form--error').empty();
            // $('.partnership-wrapper__form--error').append('Email –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π');
        }
        else {
            $('.partnership-wrapper__form--error').empty();
            $('.partnership-wrapper__form--error').append('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ username@domain.zone');
            e.preventDefault();
        }
    });

});


function validateEmail(email) {
    var filter = /^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/;
    if (filter.test(email)) {
        return true;
    }
    else {
        return false;
    }
}
/*http://zoomsl.sergeland.ru Sergey Zaragulov skype: deeserge icq: 287295769 sergeland@mail.ru*/
(function($, global){
"use strict";

	//utility methods
	/*$.fn.extend({
		resetzoomsl: function(){
			this.each(function(){
				
			});
		}
	});*/

	$.fn.imagezoomsl = function(options){
		options = options || {};		
		return this.each(function(){ //return jQuery obj		
			if (!$(this).is("img")) return true;			
			var that = this;			
            setTimeout(function () {
				$(new Image()).load(function(){				
					sergelandimagezoomer.init($(that), options);					
				}).attr('src', $(that).attr('src'));				
            }, 30);
		});

	};

	var sergelandimagezoomer = {};	
	$.extend(sergelandimagezoomer, {

		dsetting: { //default settings
		
				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				loadinggif: '',      				  // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				loadopacity: 0.1,					  // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ tmb ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ	big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				loadbackground: '#878787',			  // ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ tmb ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ	 big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ

				
				// ÔøΩÔøΩÔøΩÔøΩ (cursorshade)
				cursorshade: true,						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ
				magnifycursor: 'crosshair',				// ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ tmb ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ CSS
				cursorshadecolor: '#fff',				// ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ CSS
				cursorshadeopacity: 0.3,				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ
				cursorshadeborder: '1px solid black', 	// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ CSS
				zindex: '', 							// z-index ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ 
				stepzoom: 0.5,							// ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ					
				zoomrange: [2, 2], 						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				zoomstart: 2,							// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				disablewheel: true,					    // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ tmb ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ

				
				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ (statusdiv)
				showstatus: true, 						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ tmb help ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				showstatustime: 2000,                   // ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ help ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				statusdivborder: '1px solid black', 
				statusdivbackground: '#C0C0C0', 
				statusdivpadding: '4px', 
				statusdivfont: 'bold 13px Arial', 
				statusdivopacity: 0.8,

				
				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ (magnifier)
				magnifierpos: 'right',    				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ left/right
				magnifiersize: [0, 0], 					// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ  
				magnifiereffectanimate: 'showIn',       // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ/ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ fadeIn/showIn/slideIn
				innerzoom: false,						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ tmb
				innerzoommagnifier: false,				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ
				descarea: false,						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ, ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ descarea ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ width ÔøΩ height				
				leftoffset:  15, 						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ tmb ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				rightoffset: 15, 						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ tmb ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				switchsides: true,						// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
                magnifierborder: '1px solid black',     // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ

				
				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				textdnbackground: '#fff',               
				textdnpadding: '10px',
				textdnfont: '13px/20px cursive',

				
                // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				scrollspeedanimate: 5 /*4*/,		    // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
				zoomspeedanimate: 7, 			        // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ (ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ)
				loopspeedanimate: 2.5 /*2.45342*/ ,		// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ				
				magnifierspeedanimate: 350, 		    // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ big ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ

				
				// ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ
				classmagnifier:   "magnifier",
				classcursorshade: "cursorshade",
				classstatusdiv:   "statusdiv",
				classtextdn:      "textdn",
				classtracker:	  "tracker"

			},
	
		//isie: (function(){/*@cc_on @*//*@if(@_jscript_version >= 5)return true;@end @*/return false;})(), //is this IE?
		isie: (function(){		
			var nAgt = navigator.userAgent;			
			if(nAgt.indexOf("MSIE") != -1) return true;
			else return false;
		})(),
		
		//isMobile: (function(){ if( navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i) ){ return true; } })(),
		
		highestzindex: function($img){
		
			var z = 0, $els = $img.parents().add($img), elz;			
			$els.each(function(){			
				elz = $(this).css('zIndex');
				elz = isNaN(elz) ? 0 : + elz;
				z = Math.max(z, elz);
			});			
			return z;
		},

		getboundary: function(b, val, specs){ 		 
			if (b == "left"){			
				var rb = -specs.img.w*specs.newpower + specs.magnifier.w;
				return (val > 0) ? 0 : (val < rb) ? rb : val;
			}
			else{			
				var tb = -specs.img.h*specs.newpower + specs.magnifier.h;
				return (val > 0) ? 0 : (val < tb) ? tb : val;
			}
		},		
		
        controlLoop: function ($tracker) {			              			   
			var self  = this,
                specs = $tracker.data('specs');			 
			if(!specs)	return;

			var coords = specs.$img.offsetsl(),
				pageX = self.cld.pageX999 - coords.left,
				pageY = self.cld.pageY999 - coords.top;

			self.cld.destU += (self.cld.pageX999 - self.cld.destU) / 2.45342;
			self.cld.destV += (self.cld.pageY999 - self.cld.destV) / 2.45342; 

			specs.$statusdiv.css({left: self.cld.destU - 10, top: self.cld.destV + 20});
			
			var	  csw = Math.round( specs.magnifier.w/specs.newpower), 
				  csh = Math.round( specs.magnifier.h/specs.newpower);						

				self.cld.destK += (pageX - self.cld.destK) / specs.setting.loopspeedanimate;
				self.cld.destL += (pageY - self.cld.destL) / specs.setting.loopspeedanimate; 

				specs.$cursorshade.css({ left: specs.img.w > csw ? Math.min(specs.img.w - csw, Math.max(0, self.cld.destK - csw/2 )) + coords.left - specs.cursorshade999.border999.left999 : coords.left - specs.cursorshade999.border999.left999, 
										  top: specs.img.h > csh ? Math.min(specs.img.h - csh, Math.max(0, self.cld.destL - csh/2 )) + coords.top  - specs.cursorshade999.border999.top999  : coords.top  - specs.cursorshade999.border999.top999 });
									   
				if(specs.setting.innerzoommagnifier){
				
					self.cld.destM += (self.cld.pageX999 - self.cld.destM) / specs.setting.loopspeedanimate;
					self.cld.destN += (self.cld.pageY999 - self.cld.destN) / specs.setting.loopspeedanimate; 

					specs.$magnifier.css({
						left: self.cld.destM - Math.round(specs.magnifier.w/2),
						top:  self.cld.destN - Math.round(specs.magnifier.h/2)
					});					
					specs.$textdn.css({
						left: self.cld.destM - Math.round(specs.magnifier.w/2), 
						top:  self.cld.destN + specs.magnifier.h/2 
					});					
				}			
 
			self.cld.currU += (pageX - self.cld.currU) / specs.setting.scrollspeedanimate;
			self.cld.currV += (pageY - self.cld.currV) / specs.setting.scrollspeedanimate; 			
			
			var newx = -self.cld.currU*specs.newpower + specs.magnifier.w/2; 
			var newy = -self.cld.currV*specs.newpower + specs.magnifier.h/2;

			specs.$bigimage.css({left: self.getboundary('left', newx, specs), top:  self.getboundary('top',  newy, specs)});
            self.cld.controlTimer = setTimeout(function () {			
					self.controlLoop($tracker);
            }, 30);		

        },

        controlLoop2: function ($tracker) {			
               			   
			var self  = this,
                specs = $tracker.data('specs');	
            if(!specs)	return;		
			
			specs.currM += (specs.newpower - specs.currM) / specs.setting.zoomspeedanimate;			 	
			specs.currM = Math.round( specs.currM * 1000 ) / 1000;	
			
			specs.$cursorshade.css({  width: specs.img.w > Math.round( specs.magnifier.w/specs.currM ) ? Math.round( specs.magnifier.w/specs.currM ) : specs.img.w, 
									 height: specs.img.h > Math.round( specs.magnifier.h/specs.currM ) ? Math.round( specs.magnifier.h/specs.currM ) : specs.img.h });							  
			specs.$bigimage.css({  width: Math.round( specs.currM*specs.bigimage.w*(specs.img.w/specs.bigimage.w) ), 
								  height: Math.round( specs.currM*specs.bigimage.h*(specs.img.h/specs.bigimage.h) ) });

            self.cld.controlTimer2 = setTimeout(function () {			
					self.controlLoop2($tracker);
            }, 30);	
									   
        },		
		
		cld:{},

		showimage: function($tracker){
		
			var self   = this,
				specs  = $tracker.data('specs'),
				width  = specs.setting.magnifiersize[0], 
				height = specs.setting.magnifiersize[1],
				magcoords = {},
				coords = specs.$img.offsetsl(),
				func = function(){},
                left1   = 0,
                top1    = 0;				

			magcoords.left = coords.left + (specs.setting.magnifierpos === 'left' ? -specs.magnifier.w - specs.setting.leftoffset : specs.img.w + specs.setting.rightoffset);											  
			if(specs.setting.switchsides && !specs.setting.innerzoom){
							
				if(specs.setting.magnifierpos !== 'left' && magcoords.left + specs.magnifier.w + specs.setting.leftoffset >= $(window).width() && coords.left - specs.magnifier.w >= specs.setting.leftoffset)			
					magcoords.left = coords.left - specs.magnifier.w - specs.setting.leftoffset;				
				 else if(specs.setting.magnifierpos === 'left' && magcoords.left < 0)			
					magcoords.left = coords.left + specs.img.w + specs.setting.rightoffset;					
			}						
			
			left1  = magcoords.left;
			top1   = coords.top;
			specs.$magnifier.css({visibility: "visible", display: "none"});

		    if(specs.setting.descarea){			
			   left1 = $(specs.setting.descarea).offsetsl().left;
			   top1  = $(specs.setting.descarea).offsetsl().top;			   
			}					
			if(specs.setting.innerzoommagnifier){                			
				left1 = self.cld.pageX999 - Math.round(specs.magnifier.w/2);
				top1  = self.cld.pageY999 - Math.round(specs.magnifier.h/2);
			}

			//*
            func = function(){ 
			
				specs.$textdn.stop(true, true).fadeIn(specs.setting.magnifierspeedanimate);			    
				if(!specs.setting.innerzoommagnifier) 
					specs.$textdn.css({left: left1, top: top1 + height});
			} // */			
			
			if(specs.setting.innerzoom){
			
				left1 = coords.left; 
				top1  = coords.top;	
				
				func = function(){
					specs.$img.css({visibility: "hidden"});
					specs.$textdn.css({left: left1, top: top1 + height}).stop(true, true).fadeIn(specs.setting.magnifierspeedanimate);
				};
			}			
			
			switch (specs.setting.magnifiereffectanimate){			
			case 'slideIn':
				specs.$magnifier.css({
							left:    left1, 
							top:     top1 - height/3,
							width:   width,							
							height:  height							
						 })
					.stop(true, true).show()
					.animate({top: top1}, specs.setting.magnifierspeedanimate, "easeOutBounceSL", func);								
				break;				
			case 'showIn':
			    specs.$magnifier.css({ 	
						left:   coords.left + Math.round(specs.img.w/2), 
						top:  	coords.top  + Math.round(specs.img.h/2), 
						width:  Math.round(specs.magnifier.w/5), 
						height: Math.round(specs.magnifier.h/5) 
					 })
					.stop(true, true).show().css({opacity: "0.1"})
					.animate({ 	
						left: left1, 
						top: top1, 
						opacity: "1", 
						width: width, 
						height: height
						
					 }, specs.setting.magnifierspeedanimate, func );			
				break;				
			default:
				specs.$magnifier.css({		
							left:   left1, 
							top:    top1,
							width:  width, 
							height: height							
						 })
					.stop(true, true)
					.fadeIn(specs.setting.magnifierspeedanimate, func);								
			}				
			if (specs.setting.showstatus && (specs.title999 || specs.help))
				specs.$statusdiv.html(specs.title999 + '<div style="font-size:80%">' + specs.help +'</div>')
						  .stop(true, true)
						  .fadeIn().delay(specs.setting.showstatustime).fadeOut("slow");
			else specs.$statusdiv.hide();          						  
		},

		hideimage: function($tracker){
		
			var self = this,
			    specs = $tracker.data('specs'),
			    coords = specs.$img.offsetsl();
			
			switch (specs.setting.magnifiereffectanimate){		

			case 'showIn':
				specs.$magnifier.stop(true, true)
						.animate({	
							left: coords.left + Math.round(specs.img.w/2), 
							top:  coords.top  + Math.round(specs.img.h/2), 
							opacity: "0.1", 
							width:  Math.round(specs.magnifier.w/5), 
							height: Math.round(specs.magnifier.h/5)
						 }, 
						 specs.setting.magnifierspeedanimate, function(){specs.$magnifier.hide();});			
				break;
				
			default:
				specs.$magnifier.stop(true, true).fadeOut(specs.setting.magnifierspeedanimate);
			}
			
		},		
		
        /* Init function start.  */
        init: function ($img, options, gallery) {

			var setting = $.extend({}, this.dsetting, options),
			 basezindex = setting.zindex || this.highestzindex($img),
                    img = {w:$img.width(), h:$img.height()},
					cld = new cld(),
				  title = $img.attr("data-title")        ? $img.attr("data-title")        : '',
				   help = $img.attr("data-help")         ? $img.attr("data-help")         : '',
			     textdn = $img.attr("data-text-bottom")  ? $img.attr("data-text-bottom")  : '',
				   self = this,
				   newpower,
				   key,
				   $magnifier,
				   $cursorshade, 
			       $statusdiv,				   
			       $tracker,
				   $textdn;				   

			if(img.h === 0 || img.w === 0){			
				$(new Image()).load(function(){				
					self.init($img, options);					
				}).attr("src", $img.attr("src"));				
				return;
			}
			
			$img.css({visibility: "visible"});
			setting.largeimage = $img.attr("data-large") || $img.attr("src");			
			
			for (key in setting) 
			  if(setting[key] === '') setting[key] = this.dsetting[key];						
		 
			if(setting.zoomrange[0] < setting.zoomstart)
				 newpower = setting.zoomstart;
			else newpower = setting.zoomrange[0];	
		 
			if( setting.magnifiersize.toString() === '0,0' || 
				setting.magnifiersize.toString() === '')
				 if(setting.innerzoommagnifier)
					   setting.magnifiersize = [img.w/2, img.h/2];
				 else  setting.magnifiersize = [img.w,   img.h];	

			if(setting.descarea && $(setting.descarea).length){			
				if( $(setting.descarea).width() === 0 || $(setting.descarea).height() === 0 )
					 setting.descarea = false; 
				else setting.magnifiersize = [$(setting.descarea).width(), $(setting.descarea).height()];	
			}			
			else setting.descarea = false;

			if(setting.innerzoom){			
				setting.magnifiersize = [img.w, img.h];			
				if(!options.cursorshade)
					setting.cursorshade = false;				
				if(!options.scrollspeedanimate)
					setting.scrollspeedanimate = 10;
			}			

			if(setting.innerzoommagnifier){	
				if(!options.magnifycursor)				
					if(window.chrome || window.sidebar)
						 setting.magnifycursor = "none";				
				setting.cursorshade = false;				
				setting.magnifiereffectanimate = "fadeIn";				
			}
			
			// === == === //
			
            function cld(){
			  this.pageX999 = 0;
			  this.pageY999 = 0; 
			}
			// === == === //
			
			function getspecs($bigimage){			
				
				$tracker.data("specs", {

					setting:      setting,
					title999:     title,
					help:         help,
					 
					$img:         $img,
					$magnifier:   $magnifier,
					$bigimage:    $bigimage,
					$statusdiv:   $statusdiv,
					$cursorshade: $cursorshade,
					$textdn:      $textdn,
					
					img: img,
					bigimage:    { w:$bigimage.width(),    h:$bigimage.height()   },	
					magnifier:   { w:$magnifier.width(),   h:$magnifier.height()  },
					cursorshade999: { w:$cursorshade.width(), h:$cursorshade.height(), 
								   border999:{ left999: parseInt($cursorshade.css("border-left-width")) || 0, 
									            top999: parseInt($cursorshade.css("border-top-width"))  || 0}},
					
					currM:    newpower,
					newpower: newpower	
				});			
									  
			}			
             // === == === //
			 
			function isImageLoaded(img) {			
				if (!img.complete)
					return false;				
				if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0)
					return false;					
				return true;
			}
            // === == === //
			
			var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
			var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
			var lowestDelta, lowestDeltaXY;

			if ( $.event.fixHooks ) {
				for ( var i = toFix.length; i; ) {
					$.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
				}
			}

			$.event.special.mousewheel = {
				setup: function() {
					if ( this.addEventListener ) {
						for ( var i = toBind.length; i; ) {
							this.addEventListener( toBind[--i], handler, false );
						}
					} else {
						this.onmousewheel = handler;
					}
				},

				teardown: function() {
					if ( this.removeEventListener ) {
						for ( var i = toBind.length; i; ) {
							this.removeEventListener( toBind[--i], handler, false );
						}
					} else {
						this.onmousewheel = null;
					}
				}
			};
			
			function handler(event) {
				var orgEvent = event || window.event,
					args = [].slice.call(arguments, 1),
					delta = 0,
					deltaX = 0,
					deltaY = 0,
					absDelta = 0,
					absDeltaXY = 0,
					fn;
				event = $.event.fix(orgEvent);
				event.type = "mousewheel";

				// Old school scrollwheel delta
				if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
				if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

				// New school wheel delta (wheel event)
				if ( orgEvent.deltaY ) {
					deltaY = orgEvent.deltaY * -1;
					delta  = deltaY;
				}
				if ( orgEvent.deltaX ) {
					deltaX = orgEvent.deltaX;
					delta  = deltaX * -1;
				}

				// Webkit
				if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
				if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

				// Look for lowest delta to normalize the delta values
				absDelta = Math.abs(delta);
				if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
				absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
				if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

				// Get a whole value for the deltas
				fn = delta > 0 ? "floor" : "ceil";
				delta  = Math[fn](delta / lowestDelta);
				deltaX = Math[fn](deltaX / lowestDeltaXY);
				deltaY = Math[fn](deltaY / lowestDeltaXY);

				// Add event and delta to the front of the arguments
				args.unshift(event, delta, deltaX, deltaY);

				return ($.event.dispatch || $.event.handle).apply(this, args);
			}						

			// === == === //
			
			$.fn.offsetsl = function(){			
			    var elem = this.get(0);
				function getOffsetSum(elem) {
					var top999 = 0, left999 = 0;					
					while(elem) {
						top999 = top999 + parseInt(elem.offsetTop);
						left999 = left999 + parseInt(elem.offsetLeft);
						elem = elem.offsetParent;
					}
					return {top: top999, left: left999}
				}				
				if (elem.getBoundingClientRect)
					 return this.offset();
				else return getOffsetSum(elem)				
			}

			// === == === //
			
			 $.easing.easeOutBounceSL = function (x, t, b, c, d) {
				if ((t/=d) < (1/2.75)) {
					return c*(7.5625*t*t) + b;
				} else if (t < (2/2.75)) {
					return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
				} else if (t < (2.5/2.75)) {
					return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
				} else {
					return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
				}
			}
			
			 // === == === //			 

			$magnifier = $("<div />")
				.attr({	"class": setting.classmagnifier })
				.css({	position: "absolute",
						zIndex: basezindex,
						width:  setting.magnifiersize[0],
						height: setting.magnifiersize[1],
						left: -10000,
						top: -10000,
						visibility: "hidden",
						overflow: "hidden" 
					})
				.appendTo(document.body); 

			if(!options.classmagnifier)				
				$magnifier.css({border: setting.magnifierborder});
							
			$cursorshade = $("<div />");
			if(setting.cursorshade){			
				$cursorshade.attr({ "class": setting.classcursorshade })
					.css({
							zIndex: basezindex,
							display: "none",
							position: "absolute",
							width:  Math.round(setting.magnifiersize[0]/setting.zoomstart),
							height: Math.round(setting.magnifiersize[1]/setting.zoomstart),
							top:  0,
							left: 0	
						})
					.appendTo(document.body);

				if(!options.classcursorshade)
					$cursorshade.css({
							border:          setting.cursorshadeborder, 
							opacity:         setting.cursorshadeopacity, 
							backgroundColor: setting.cursorshadecolor					
					});		   
			}			

			if(!setting.loadinggif)
				setting.loadinggif = "data:image/gif;base64,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";
			
			$statusdiv = $("<div />")
				.attr({	"class": setting.classstatusdiv + " preloadevt" })
				.css({	position: "absolute",
						display: "none",
						zIndex: basezindex,
						top:  0,
						left: 0	
					 })
				.html('<img src="' + setting.loadinggif + '" />')
				.appendTo(document.body); 
		
			$tracker = $("<div />")
						.attr({	"class": setting.classtracker })
						.css({	zIndex: basezindex,
								backgroundImage: self.isie ? "url(cannotbe)" : "none",
								position: "absolute",
								width:  img.w,
								height: img.h,
								left:   gallery ? $img.offsetsl().left : -10000,
								top:    gallery ? $img.offsetsl().top : -10000
							}).appendTo(document.body);

			$textdn = $("<div />");		
			if(textdn){
				$textdn.attr({	"class": setting.classtextdn })
					.css({	position: "absolute",
							zIndex: basezindex,
							left: 0,
							top: 0,
							display: "none"
						})
					.html(textdn)	
					.appendTo(document.body); 							
				if(!options.classtextdn)				
					$textdn.css({
						border:     setting.magnifierborder, 
						background: setting.textdnbackground,
						padding:    setting.textdnpadding,
						font: 		setting.textdnfont
					});				
				$textdn.css({width: setting.magnifiersize[0] - parseInt($textdn.css("padding-left")) - parseInt($textdn.css("padding-right"))});			
			}
			$tracker.data("largeimage", setting.largeimage);				

			
			// EVENTS			
			$(window).bind("resize", function(){ 			
					var o = $img.offsetsl();					
					if($tracker.data("loadimgevt"))
						$tracker.css({left: o.left, top: o.top});						
					$statusdiv.filter(".preloadevt").css({left:o.left + img.w/2 - $statusdiv.width()/2, top:o.top + img.h/2 - $statusdiv.height()/2, visibility:'visible'});					
			 });			
			$(document).mousemove(function(e){				
				self.cld.docX = e.pageX;				
				if(self.cld.pageX999 !== self.cld.docX){
					clearTimeout(self.cld.controlTimer);
					clearTimeout(self.cld.controlTimer2);				
					$img.css({visibility: "visible"});					
					//$tracker.hide().css({left: 10000, top: 10000});					
				}
			});			
           $img.mouseover(function(e){				
				var o = $img.offsetsl();
				$tracker.css({left: o.left, top: o.top}).show();		   
		   });		
           $tracker.mouseover(function(e){
			   
				self.cld.pageX999 = e.pageX;
				self.cld.pageY999 = e.pageY;								
				
				cld.pageX999 = e.pageX;
				cld.pageY999 = e.pageY;
				
				self.cld.docX = e.pageX;
				
				var o = $img.offsetsl(),
					pageX = self.cld.pageX999 - o.left,
					pageY = self.cld.pageY999 - o.top;						
					
				self.cld.destK = pageX;
				self.cld.destL = pageY;

				self.cld.currU = pageX;				
				self.cld.currV = pageY;				
				              			
				self.cld.destM = self.cld.pageX999; 
				self.cld.destN = self.cld.pageY999;
				
				self.cld.destU = self.cld.pageX999 - 10;
				self.cld.destV = self.cld.pageY999 + 20;
				
				$tracker.css({cursor: setting.magnifycursor});
				setting.largeimage = $img.attr("data-large") || $img.attr("src");
								
				$statusdiv.show();
				clearTimeout(self.cld.controlTimer);
				clearTimeout(self.cld.controlTimer2);				

				if(setting.largeimage !== $tracker.data('largeimage')){	
				
					$(new Image()).load(function(){						
					}).attr("src", setting.largeimage);	
			
					$($tracker).unbind();
					$($statusdiv).remove();
					$($cursorshade).remove(); 
					$($magnifier).remove();						
					$($tracker).remove();
					$($textdn).remove();
					
					self.init($img, options, true);							
				}								
				if( $tracker.data("loadevt") ){							
					$cursorshade.fadeIn();
					self.showimage($tracker);
					self.controlLoop($tracker);	
					self.controlLoop2($tracker);
				}
				
            });											
            $tracker.mousemove(function(e){
				setting.largeimage = $img.attr("data-large") || $img.attr("src");
				if(setting.largeimage !== $tracker.data("largeimage")){	
				
					$(new Image()).load(function(){						
					}).attr("src", setting.largeimage);	
			
					$($tracker).unbind();
					$($statusdiv).remove();
					$($cursorshade).remove(); 
					$($magnifier).remove();						
					$($tracker).remove();
					$($textdn).remove();
					
					self.init($img, options, true);							
				}
				
                self.cld.pageX999 = e.pageX;
                self.cld.pageY999 = e.pageY;
				
				cld.pageX999 = e.pageX;
                cld.pageY999 = e.pageY;
				
				self.cld.docX = e.pageX;
            });			
            $tracker.mouseout(function(e) {		
				clearTimeout(self.cld.controlTimer);
				clearTimeout(self.cld.controlTimer2);			
			    $img.css({visibility: "visible"});			
				$textdn.hide();					
				$cursorshade.add($statusdiv.not(".preloadevt")).stop(true, true).hide();			
            });
			$tracker.one("mouseover", function(e){	
			
				var imgcoords = $img.offsetsl();
				var $bigimage = $('<img src="' + setting.largeimage + '"/>').css({position:"relative", maxWidth:"none"}).appendTo($magnifier);				
				if(!self.loaded999[setting.largeimage]){	
					$tracker.css({opacity: setting.loadopacity, background: setting.loadbackground});				
					$tracker.data("loadimgevt", true);
					$statusdiv.css({left:imgcoords.left + img.w/2 - $statusdiv.width()/2, top:imgcoords.top + img.h/2 - $statusdiv.height()/2, visibility:'visible'});
				}						 
				$bigimage.bind("loadevt", function(event, e){ 
					
					if(e.type === "error") return;											
					$tracker.mouseout(function(e){ //image onmouseout						
							self.hideimage($tracker);
							clearTimeout(self.cld.controlTimer);
							clearTimeout(self.cld.controlTimer2);
							$img.css({visibility: "visible"});
                            $textdn.hide();							
							$tracker.hide().css({left: -10000, top: -10000});							
					});					
					$tracker.mouseover(function(e){ //image onmouseover	
							specs.currM = specs.newpower;						
					}); 				
					$tracker.data("loadimgevt", false);
					$tracker.css({opacity:0, cursor:setting.magnifycursor});
					$statusdiv.empty();
					if(!options.classstatusdiv)
						$statusdiv.css({
										  border:     setting.statusdivborder, 
										  background: setting.statusdivbackground, 
										  padding:    setting.statusdivpadding, 
										  font:       setting.statusdivfont, 
										  opacity:    setting.statusdivopacity
									   });										
					$statusdiv.hide().removeClass("preloadevt");
					self.loaded999[setting.largeimage] = true;
					getspecs($bigimage); 		
		            if(cld.pageX999 == self.cld.docX){
						$cursorshade.fadeIn();
						self.showimage($tracker);
						clearTimeout(self.cld.controlTimer);
						clearTimeout(self.cld.controlTimer2);
						self.controlLoop($tracker);	
						self.controlLoop2($tracker);					
					}
					
					var specs = $tracker.data("specs");										    					
					$bigimage.css({width: setting.zoomstart*specs.bigimage.w*(img.w/specs.bigimage.w), height: setting.zoomstart*specs.bigimage.h*(img.h/specs.bigimage.h)});				
					$tracker.data("loadevt", true);					
					
					if (setting.zoomrange && setting.zoomrange[1] > setting.zoomrange[0]){ //if zoom range enabled					
						$tracker.bind("mousewheel", function(e, delta){						
							 var zoomdir  = delta < 0 ? "out" : "in",
								 power    = specs.newpower,
								 newpower = (zoomdir == "in") ? Math.min(power + setting.stepzoom, setting.zoomrange[1]) : Math.max(power - setting.stepzoom, setting.zoomrange[0]);

							specs.newpower = newpower;
							specs.delta = delta;							
							e.preventDefault();
						});
						
					} else if(setting.disablewheel){
						$tracker.bind("mousewheel", function(e){e.preventDefault();});
					}
					
				});	//end $bigimage onload */
				
				if ( isImageLoaded($bigimage.get(0)) )				
					  $bigimage.trigger("loadevt", {type: "load"});					 
				else  $bigimage.bind("load error", function(e){$bigimage.trigger("loadevt", e)});				
			});
        },	
		loaded999: {}		
	});
})(jQuery, window);
 var menu = document.querySelector('.button-wrapper');
 var main = document.querySelector('body');
 var drawer = document.querySelector('.nav');

 menu.addEventListener('click', function(e) {
     menu.classList.toggle('active')
     
     drawer.classList.toggle('open');
     e.stopPropagation();
 });
 main.addEventListener('click', function(event) {
     if(drawer.classList.contains('open')) {
         if (target === drawer || drawer.contains(target)) {
             return
         }
         menu.classList.toggle('active')
         var target = event.target;
         drawer.classList.remove('open');
     }
 });